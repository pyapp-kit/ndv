{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ndv","text":"<p>Simple, fast-loading, asynchronous, n-dimensional array viewer, with minimal dependencies.</p> <p>Works in Qt, Jupyter, or wxPython.</p> <pre><code>import ndv\n\ndata = ndv.data.cells3d()  # or any arraylike object\nndv.imshow(data)\n</code></pre> <p></p> <p><code>ndv.imshow()</code> creates an instance of <code>ndv.ArrayViewer</code>, which you can also use directly:</p> <pre><code>import ndv\n\nviewer = ndv.ArrayViewer(data)\nviewer.show()\nndv.run_app()\n</code></pre> <p>Tip</p> <p>To embed the viewer in a broader Qt or wxPython application, you can access the viewer's <code>widget</code> attribute and add it to your layout.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\u26a1\ufe0f fast to import, fast to show</li> <li>\ud83e\udeb6 minimal dependencies</li> <li>\ud83d\udce6 supports arbitrary number of dimensions</li> <li>\ud83e\udd49 2D/3D view canvas</li> <li>\ud83c\udf20 supports VisPy or   pygfx backends</li> <li>\ud83d\udee0\ufe0f support Qt, wx, or   Jupyter GUI frontends</li> <li>\ud83c\udfa8 colormaps provided by cmap</li> <li>\ud83c\udff7\ufe0f supports named dimensions and categorical coordinate values (WIP)</li> <li>\ud83e\udd86 supports most array types, including:<ul> <li><code>numpy.ndarray</code></li> <li><code>cupy.ndarray</code></li> <li><code>dask.array.Array</code></li> <li><code>jax.Array</code></li> <li><code>pyopencl.array.Array</code></li> <li><code>sparse.COO</code></li> <li><code>tensorstore.TensorStore</code> (supports named dimensions)</li> <li><code>torch.Tensor</code> (supports named dimensions)</li> <li><code>xarray.DataArray</code> (supports named dimensions)</li> <li><code>zarr</code> (named dimensions WIP)</li> </ul> </li> </ul> <p>See examples for each of these array types in examples</p> <p>Note</p> <p>You can add support for any custom storage class by subclassing <code>ndv.DataWrapper</code> and implementing a couple methods. (This doesn't require modifying ndv, but contributions of new wrappers are welcome!)</p>"},{"location":"#installation","title":"Installation","text":"<p>Because ndv supports many combinations of GUI and graphics frameworks, you must install it along with additional dependencies for your desired backend.</p> <p>See the installation guide for complete details.</p> <p>To just get started quickly using Qt and vispy:</p> <pre><code>pip install ndv[qt]\n</code></pre> <p>For Jupyter with vispy, (no Qt or wxPython):</p> <pre><code>pip install ndv[jup]\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>For more information, and complete API reference, see the documentation.</p>"},{"location":"env_var/","title":"Environment Variables","text":"<p><code>ndv</code> recognizes the following environment variables:</p> <p>Boolean variables can be set to <code>1</code>, <code>0</code>, <code>True</code>, or <code>False</code> (case insensitive).</p> Variable Description Default <code>NDV_CANVAS_BACKEND</code> Explicitly choose the graphics library: <code>\"vispy\"</code> or <code>\"pygfx\"</code> auto <code>NDV_GUI_FRONTEND</code> Explicitly choose the GUI library: <code>\"qt\"</code>, <code>\"wx\"</code>, or <code>\"jupyter\"</code> auto <code>NDV_DEBUG_EXCEPTIONS</code> Whether to drop into a debugger when an exception is raised. (for development) <code>False</code> <code>NDV_EXIT_ON_EXCEPTION</code> Whether to exit the application on the first unhandled exception. (for development) <code>False</code> <code>NDV_IPYTHON_MAGIC</code> Whether to use <code>%gui</code> magic when running in IPython, to enable interactive usage. <code>True</code> <code>NDV_SYNCHRONOUS</code> Whether to force data request/draw to be synchronous. (*note: this currently has no effect on Jupyter, which is always asynchronous) <code>False</code>"},{"location":"env_var/#framework-selection","title":"Framework selection","text":"<p>Depending on how you've installed ndv, you may end up with multiple supported GUI or graphics libraries installed. You can control which ones <code>ndv</code> uses with <code>NDV_CANVAS_BACKEND</code> and <code>NDV_GUI_FRONTEND</code>, respectively, as described above.  Note that currently, only one GUI framework can be used per session.</p> <p>Defaults</p> <p>GUI:</p> <p><code>ndv</code> tries to be aware of the GUI library you are using. So it will use <code>jupyter</code> if you are in a Jupyter notebook, <code>qt</code> if a <code>QApplication</code> is already running, and <code>wx</code> if a <code>wx.App</code> is already running. Finally, it will check for the availability of libraries in the order of <code>qt</code>, <code>wx</code>, <code>jupyter</code>.</p> <p>Graphics:</p> <p>If you have both VisPy and pygfx installed, <code>ndv</code> will (currently) default to using VisPy.</p>"},{"location":"install/","title":"Installation","text":"<p>TLDR;</p> For a desktop usageFor Jupyter notebook/lab <pre><code>pip install \"ndv[vispy,pyqt]\"\n</code></pre> <pre><code>pip install \"ndv[vispy,jupyter]\"\n</code></pre> <p><code>ndv</code> can be used in a variety of contexts. It supports various GUI  frameworks, including PyQt,  PySide, wxPython,  and Jupyter Lab &amp; Notebooks.  It also works with  different graphics libraries, including VisPy (for  OpenGL) and Pygfx (for WebGPU).</p> <p>These frameworks are not included directly with <code>ndv</code> and must be installed independently. We provide a set of installation extras depending on the graphics and GUI libraries you want to use:</p> <p>Framework Selection</p> <p>If you have multiple supported GUI or graphics libraries installed, you can select which ones <code>ndv</code> uses with environment variables.</p>"},{"location":"motivation/","title":"Motivation and Scope","text":"<p>It can be informative to know what problems the developers were trying to solve when creating a library, and under what constraints. <code>ndv</code> was created by a former napari core developer and collaborators out of a desire to quickly view multi-dimensional arrays with minimal import times minimal dependencies. The original need was for a component in a broader (microscope control) application, where a fast and minimal viewer was needed to display data.</p>"},{"location":"motivation/#goals","title":"Goals","text":"<ul> <li> N-dimensional viewer: The current focus is on viewing multi-dimensional     arrays (and currently just a single array at a time), with sliders     controlling slicing from an arbitrary number of dimensions. 2D and 3D     volumetric views are supported.</li> <li> Minimal dependencies: <code>ndv</code> should have as few dependencies  as     possible (both direct and indirect). Installing <code>napari[all]==0.5.5</code> into a     clean environment brings a total of 126 dependencies. <code>ndv[qt]==0.2.0</code> has     29, and we aim to keep that low.</li> <li> Quick to import: <code>ndv</code> should import and show a viewer in a reasonable     amount of time. \"Reasonable\" is of course relative and subjective, but we     aim for less than 1 second on a modern laptop (currently at &lt;100ms).</li> <li> Broad GUI Compatibility: A common feature request for <code>napari</code> is to support     Jupyter notebooks. <code>ndv</code> can work with Qt,     wxPython, and Jupyter.</li> <li> Flexible Graphics Providers: <code>ndv</code> works with VisPy in a classical OpenGL     context, but has an abstracting layer that allows for other graphics engines.     We currently also support <code>pygfx</code>, a WGPU-based graphics engine.</li> <li> Model/View architecture: <code>ndv</code> should have a clear separation between the     data model and the view. The model should be serializable and easily     transferable between different views. (The primary model is currently     <code>ArrayDisplayModel</code>)</li> <li> Asynchronous first: <code>ndv</code> should be asynchronous by default: meaning     that the data request/response process happens in the background, and the     GUI remains responsive. (Optimization of remote, multi-resolution data is on     the roadmap, but not currently implemented).</li> </ul>"},{"location":"motivation/#scope-and-roadmap","title":"Scope and Roadmap","text":"<p>We do want to support the following features:</p> <ul> <li> Multiple data sources: We want to allow for multiple data sources to be     displayed in the same viewer, with flexible coordinate transforms.</li> <li> Non-image data: We would like to support non-image data, such as points     segmentation masks, and meshes.</li> <li> Multi-resolution (pyramid) data: We would like to support multi-resolution     data, to allow for fast rendering of large datasets based on the current view.</li> <li> Frustum culling: We would like to support frustum culling to allow for     efficient rendering of large datasets.</li> <li> Ortho-viewer: <code>ndv</code>'s clean model/view separation should allow for     easy creation of an ortho-viewer (e.g. synchronized <code>XY</code>, <code>XZ</code>, <code>YZ</code> views).</li> </ul>"},{"location":"motivation/#non-goals","title":"Non-Goals","text":"<p>We do not plan to support the following features in the near future (if ever):</p> <ul> <li>Oblique Slicing: While not an explicit non-goal, oblique slicing (\u00e0 la     Big Data Viewer) is different enough     that it won't realistically be implemented in the near future.</li> <li>Image Processing: General image processing is out of scope. We aim to     provide a viewer, not a full image processing library.</li> <li>Interactive segmentation and painting: While extensible mouse event handling     is in scope, we don't intend to implement painting or  interactive     segmentation tools.</li> <li>Plugins: We don't intend to support a plugin architecture. We aim to keep     the core library as small as possible, and encourage users to build on top     of it with their own tools.</li> </ul>"},{"location":"cookbook/embedding/","title":"Embedding <code>ArrayViewer</code>","text":"<p><code>ndv</code> can be embedded in an existing Qt (or wx) application and enriched with additional elements in a custom layout. The following document shows some examples of such implementation.</p> <p>The key in each case is the use of the <code>ArrayViewer.widget</code> method, which returns a native widget for the current GUI backend.</p>"},{"location":"cookbook/embedding/#change-the-content-of-arrayviewer-via-push-buttons","title":"Change the content of <code>ArrayViewer</code> via push buttons","text":"<p>The following script shows an example on how to dynamically select a data set and load it in the <code>ArrayViewer</code>.</p> examples/cookbook/ndv_embedded.py<pre><code># /// script\n# dependencies = [\n#   \"ndv[vispy,pyqt]\",\n#   \"imageio[tifffile]\",\n# ]\n# ///\n\"\"\"An example on how to embed the `ArrayViewer` controller in a custom Qt widget.\"\"\"\n\nfrom qtpy import QtWidgets\n\nfrom ndv import ArrayViewer, run_app\nfrom ndv.data import astronaut, cat\n\n\nclass EmbeddingWidget(QtWidgets.QWidget):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self._viewer = ArrayViewer()\n\n        self._cat_button = QtWidgets.QPushButton(\"Load cat image\")\n        self._cat_button.clicked.connect(self._load_cat)\n\n        self._astronaut_button = QtWidgets.QPushButton(\"Load astronaut image\")\n        self._astronaut_button.clicked.connect(self._load_astronaut)\n\n        btns = QtWidgets.QHBoxLayout()\n        btns.addWidget(self._cat_button)\n        btns.addWidget(self._astronaut_button)\n\n        layout = QtWidgets.QVBoxLayout(self)\n        # `ArrayViewer.widget()` returns the native Qt widget\n        layout.addWidget(self._viewer.widget())\n        layout.addLayout(btns)\n\n        self._load_cat()\n\n    def _load_cat(self) -&gt; None:\n        self._viewer.data = cat().mean(axis=-1)\n\n    def _load_astronaut(self) -&gt; None:\n        self._viewer.data = astronaut().mean(axis=-1)\n\n\napp = QtWidgets.QApplication([])\nwidget = EmbeddingWidget()\nwidget.show()\nrun_app()\n</code></pre> <p> </p>"},{"location":"cookbook/embedding/#use-multiple-ndvarrayviewer-controllers-in-the-same-widget","title":"Use multiple <code>ndv.ArrayViewer</code> controllers in the same widget","text":"<p>The following script shows an example on how to create multiple instances of the <code>ArrayViewer</code> controller in the same widget and load two different datasets in each one.</p> examples/cookbook/multi_ndv.py<pre><code># /// script\n# dependencies = [\n#   \"ndv[vispy,pyqt]\",\n#   \"imageio[tifffile]\",\n# ]\n# ///\n\"\"\"An example on how to embed multiple `ArrayViewer` controllers in a custom Qt widget.\n\nIt shows the `astronaut` and `cells3d` images side by side on two different viewers.\n\"\"\"\n\nfrom qtpy import QtWidgets\n\nfrom ndv import ArrayViewer, run_app\nfrom ndv.data import astronaut, cells3d\n\n\nclass MultiNDVWrapper(QtWidgets.QWidget):\n    def __init__(self) -&gt; None:\n        super().__init__()\n\n        self._astronaut_viewer = ArrayViewer(astronaut().mean(axis=-1))\n        self._cells_virewer = ArrayViewer(cells3d(), current_index={0: 30, 1: 1})\n\n        # get `ArrayViewer` widget and add it to the layout\n        layout = QtWidgets.QHBoxLayout(self)\n        layout.addWidget(self._astronaut_viewer.widget())\n        layout.addWidget(self._cells_virewer.widget())\n\n\napp = QtWidgets.QApplication([])\nwidget = MultiNDVWrapper()\nwidget.show()\nrun_app()\n</code></pre> <p> </p>"},{"location":"cookbook/embedding/#a-minimal-microscope-dashboard-using-openwfs","title":"A minimal microscope dashboard using <code>openwfs</code>","text":"<p>You can use <code>ndv</code> to take an external image source (i.e. a widefield camera) and show its content in real-time in a custom widget embedding <code>ArrayViewer</code>. The script below uses <code>openwfs</code> to generate synthetic images of a sample and continuously update the view, and allows to move the field of view over the X and Y axis.</p> examples/cookbook/microscope_dashboard.py<pre><code># /// script\n# dependencies = [\n#   \"ndv[vispy,pyqt]\",\n#   \"openwfs\",\n# ]\n# ///\n\"\"\"A minimal microscope dashboard.\n\nThe `SyntheticManager` acts as an microscope simulator.\nIt generates images of a specimen and sends them to the `DashboardWidget`.\n\nThe `DashboardWidget` is a simple GUI that displays the images and allows the user to:\n- starts/stops the simulation;\n- move the stage in the x and y directions.\n\"\"\"\n\nfrom typing import Any, cast\n\nimport astropy.units as u\nimport numpy as np\nfrom openwfs.simulation import Camera, Microscope, StaticSource\nfrom qtpy import QtWidgets as QtW\nfrom qtpy.QtCore import QObject, Qt, Signal\n\nfrom ndv import ArrayViewer\n\n\nclass SyntheticManager(QObject):\n    newFrame = Signal(np.ndarray)\n\n    def __init__(self, parent: QObject | None = None) -&gt; None:\n        super().__init__(parent)\n\n        specimen_resolution = (1024, 1024)  # (height, width) in pixels of the image\n        specimen_pixel_size = 60 * u.nm  # resolution (pixel size) of the specimen image\n        magnification = 40  # magnification from object plane to camera.\n        numerical_aperture = 0.85  # numerical aperture of the microscope objective\n        wavelength = 532.8 * u.nm  # wavelength of the light, for computing diffraction.\n        camera_resolution = (256, 256)  # number of pixels on the camera\n\n        img = np.random.randint(-10000, 10, specimen_resolution, dtype=np.int16)\n        img = np.maximum(img, 0)\n        src = StaticSource(img, pixel_size=specimen_pixel_size)\n\n        self._microscope = Microscope(\n            src,\n            magnification=magnification,\n            numerical_aperture=numerical_aperture,\n            wavelength=wavelength,\n        )\n        self._camera = Camera(\n            self._microscope,\n            analog_max=None,\n            shot_noise=True,\n            digital_max=255,\n            shape=camera_resolution,\n        )\n\n    def move_stage(self, axis: str, step: float) -&gt; None:\n        if axis == \"x\":\n            self._microscope.xy_stage.x += step * u.um\n        if axis == \"y\":\n            self._microscope.xy_stage.y += step * u.um\n\n    def toggle_simulation(self, start: bool) -&gt; None:\n        if start:\n            self._timer_id = self.startTimer(100)\n        elif hasattr(self, \"_timer_id\"):\n            self.killTimer(self._timer_id)\n\n    def timerEvent(self, e: Any) -&gt; None:\n        self.emit_frame()\n\n    def emit_frame(self) -&gt; None:\n        self.newFrame.emit(self._camera.read())\n\n\nclass StageWidget(QtW.QGroupBox):\n    stageMoved = Signal(str, int)\n\n    def __init__(self, name: str, axes: list[str], parent: QtW.QWidget) -&gt; None:\n        super().__init__(name, parent)\n        self._data_key = \"data\"\n\n        def _make_button(txt: str, *data: Any) -&gt; QtW.QPushButton:\n            btn = QtW.QPushButton(txt)\n            btn.setAutoRepeat(True)\n            btn.setProperty(self._data_key, data)\n            btn.clicked.connect(self._move_stage)\n            return btn\n\n        layout = QtW.QVBoxLayout(self)\n        for ax in axes:\n            # spinbox showing stage position\n            spin = QtW.QDoubleSpinBox()\n            spin.setMinimumWidth(80)\n            spin.setAlignment(Qt.AlignmentFlag.AlignRight)\n            spin.setSuffix(\" \u00b5m\")\n            spin.setFocusPolicy(Qt.FocusPolicy.NoFocus)\n            spin.setButtonSymbols(QtW.QAbstractSpinBox.ButtonSymbols.NoButtons)\n\n            # buttons to move the stage\n            down = _make_button(\"-\", ax, spin)\n            up = _make_button(\"+\", ax, spin)\n\n            row = QtW.QHBoxLayout()\n            row.addWidget(QtW.QLabel(f\"&lt;strong&gt;{ax}:&lt;/strong&gt;\"), 0)\n            row.addWidget(spin, 0, Qt.AlignmentFlag.AlignRight)\n            row.addWidget(down, 1)\n            row.addWidget(up, 1)\n            layout.addLayout(row)\n\n    def _move_stage(self) -&gt; None:\n        button = cast(\"QtW.QPushButton\", self.sender())\n        ax, spin = button.property(self._data_key)\n        step = 1 if button.text() == \"+\" else -1\n        cast(\"QtW.QDoubleSpinBox\", spin).stepBy(step)\n        self.stageMoved.emit(ax, step)\n\n\nclass DashboardWidget(QtW.QWidget):\n    simulationStarted = Signal(bool)\n    stageMoved = Signal(str, int)\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n\n        self._stage_widget = StageWidget(\"Stage\", [\"x\", \"y\"], self)\n        self._stage_widget.setEnabled(False)\n        self._stage_widget.stageMoved.connect(self.stageMoved)\n\n        self._viewer = ArrayViewer()\n        self._viewer._async = False  # Disable async rendering for simplicity\n\n        self._start_button = QtW.QPushButton(\"Start\")\n        self._start_button.setMinimumWidth(120)\n        self._start_button.toggled.connect(self.start_simulation)\n        self._start_button.setCheckable(True)\n\n        bottom = QtW.QHBoxLayout()\n        bottom.setContentsMargins(0, 0, 0, 0)\n        bottom.addWidget(self._start_button)\n        bottom.addSpacing(120)\n        bottom.addWidget(self._stage_widget)\n\n        layout = QtW.QVBoxLayout(self)\n        layout.setSpacing(0)\n        layout.addWidget(self._viewer.widget(), 1)\n        layout.addLayout(bottom)\n\n    def start_simulation(self, checked: bool) -&gt; None:\n        self._stage_widget.setEnabled(checked)\n        self._start_button.setText(\"Stop\" if checked else \"Start\")\n        self.simulationStarted.emit(checked)\n\n    def set_data(self, frame: np.ndarray) -&gt; None:\n        self._viewer.data = frame\n\n\napp = QtW.QApplication([])\nmanager = SyntheticManager()\nwrapper = DashboardWidget()\n\nmanager.newFrame.connect(wrapper.set_data)\nwrapper.simulationStarted.connect(manager.toggle_simulation)\nwrapper.stageMoved.connect(manager.move_stage)\nmanager.emit_frame()  # just to populate the viewer with an image\nwrapper.show()\napp.exec()\n</code></pre> <p> </p>"},{"location":"reference/ndv/","title":"ndv","text":""},{"location":"reference/ndv/#ndv","title":"ndv","text":"<p>Fast and flexible n-dimensional data viewer.</p> <p>Modules:</p> <ul> <li> <code>controllers</code>           \u2013            <p>Controllers are the primary public interfaces that wrap models &amp; views.</p> </li> <li> <code>data</code>           \u2013            <p>Sample data for testing and examples.</p> </li> <li> <code>models</code>           \u2013            <p>Models for <code>ndv</code>.</p> </li> <li> <code>util</code>           \u2013            <p>Utility and convenience functions.</p> </li> <li> <code>views</code>           \u2013            <p>Wrappers around GUI &amp; graphics frameworks.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>ArrayViewer</code>           \u2013            <p>Viewer dedicated to displaying a single n-dimensional array.</p> </li> <li> <code>DataWrapper</code>           \u2013            <p>Interface for wrapping different array-like data types.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>imshow</code>             \u2013              <p>Display an array or DataWrapper in a new <code>ArrayViewer</code> window.</p> </li> <li> <code>run_app</code>             \u2013              <p>Start the active GUI application event loop.</p> </li> </ul>"},{"location":"reference/ndv/#ndv.ArrayViewer","title":"ArrayViewer","text":"<pre><code>ArrayViewer(\n    data: Any | DataWrapper = None,\n    /,\n    display_model: ArrayDisplayModel | None = None,\n    **kwargs: Unpack[ArrayDisplayModelKwargs],\n)\n</code></pre> <p>Viewer dedicated to displaying a single n-dimensional array.</p> <p>This wraps a model and sview into a single object, and defines the public API.</p> <p>See also</p> <p><code>ndv.imshow</code> - a convenience function that constructs and shows an <code>ArrayViewer</code>.</p> <p>Future plans</p> <p>In the future, <code>ndv</code> would like to support multiple, layered data sources with coordinate transforms. We reserve the name <code>Viewer</code> for a more fully featured viewer. <code>ArrayViewer</code> assumes you're viewing a single array.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>clone</code>             \u2013              <p>Return a new ArrayViewer instance with the same data and display model.</p> </li> <li> <code>close</code>             \u2013              <p>Close the viewer.</p> </li> <li> <code>hide</code>             \u2013              <p>Hide the viewer.</p> </li> <li> <code>show</code>             \u2013              <p>Show the viewer.</p> </li> <li> <code>widget</code>             \u2013              <p>Return the native front-end widget.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>Return data being displayed.</p> </li> <li> <code>data_wrapper</code>               (<code>Any</code>)           \u2013            <p>Return data being displayed.</p> </li> <li> <code>display_model</code>               (<code>ArrayDisplayModel</code>)           \u2013            <p>Return the current ArrayDisplayModel.</p> </li> <li> <code>roi</code>               (<code>RectangularROIModel | None</code>)           \u2013            <p>Return ROI being displayed.</p> </li> </ul> Source code in <code>src/ndv/controllers/_array_viewer.py</code> <pre><code>def __init__(\n    self,\n    data: Any | DataWrapper = None,\n    /,\n    display_model: ArrayDisplayModel | None = None,\n    **kwargs: Unpack[ArrayDisplayModelKwargs],\n) -&gt; None:\n    if display_model is not None and kwargs:\n        warnings.warn(\n            \"When display_model is provided, kwargs are be ignored.\",\n            stacklevel=2,\n        )\n    self._data_model = _ArrayDataDisplayModel(\n        data_wrapper=data, display=display_model or ArrayDisplayModel(**kwargs)\n    )\n    self._viewer_model = ArrayViewerModel()\n    self._viewer_model.events.interaction_mode.connect(\n        self._on_interaction_mode_changed\n    )\n    self._roi_model: RectangularROIModel | None = None\n\n    app = _app.gui_frontend()\n\n    # whether to fetch data asynchronously.  Not publicly exposed yet...\n    # but can use 'NDV_SYNCHRONOUS' env var to set globally\n    # jupyter doesn't need async because it's already async (in that the\n    # GUI is already running in JS)\n    NDV_SYNCHRONOUS = os.getenv(\"NDV_SYNCHRONOUS\", \"0\") in {\"1\", \"True\", \"true\"}\n    self._async = not NDV_SYNCHRONOUS and app != _app.GuiFrontend.JUPYTER\n    # set of futures for data requests\n    self._futures: set[Future[DataResponse]] = set()\n\n    # mapping of channel keys to their respective controllers\n    # where None is the default channel\n    self._lut_controllers: dict[ChannelKey, ChannelController] = {}\n\n    # get and create the front-end and canvas classes\n    frontend_cls = _app.get_array_view_class()\n    canvas_cls = _app.get_array_canvas_class()\n    self._canvas = canvas_cls(self._viewer_model)\n\n    # TODO: Is this necessary?\n    self._histograms: dict[ChannelKey, HistogramCanvas] = {}\n    self._view = frontend_cls(\n        self._canvas.frontend_widget(), self._data_model, self._viewer_model\n    )\n\n    self._roi_view: RectangularROIHandle | None = None\n\n    self._set_model_connected(self._data_model.display)\n    self._canvas.set_ndim(self.display_model.n_visible_axes)\n\n    self._view.currentIndexChanged.connect(self._on_view_current_index_changed)\n    self._view.resetZoomClicked.connect(self._on_view_reset_zoom_clicked)\n    self._view.histogramRequested.connect(self._add_histogram)\n    self._view.channelModeChanged.connect(self._on_view_channel_mode_changed)\n    self._view.visibleAxesChanged.connect(self._on_view_visible_axes_changed)\n\n    self._canvas.mouseMoved.connect(self._on_canvas_mouse_moved)\n\n    if self._data_model.data_wrapper is not None:\n        self._fully_synchronize_view()\n</code></pre>"},{"location":"reference/ndv/#ndv.ArrayViewer(data)","title":"<code>data</code>","text":"(<code> DataWrapper | Any</code>, default:                   <code>None</code> )           \u2013            <p>Data to be displayed.</p>"},{"location":"reference/ndv/#ndv.ArrayViewer(display_model)","title":"<code>display_model</code>","text":"(<code>ArrayDisplayModel</code>, default:                   <code>None</code> )           \u2013            <p>Just the display model to use. If provided, <code>data_or_model</code> must be an array or <code>DataWrapper</code>... and kwargs will be ignored.</p>"},{"location":"reference/ndv/#ndv.ArrayViewer(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Unpack[ArrayDisplayModelKwargs]</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the <code>ArrayDisplayModel</code> constructor. If <code>display_model</code> is provided, these will be ignored.</p>"},{"location":"reference/ndv/#ndv.ArrayViewer.data","title":"data  <code>property</code> <code>writable</code>","text":"<pre><code>data: Any\n</code></pre> <p>Return data being displayed.</p>"},{"location":"reference/ndv/#ndv.ArrayViewer.data_wrapper","title":"data_wrapper  <code>property</code>","text":"<pre><code>data_wrapper: Any\n</code></pre> <p>Return data being displayed.</p>"},{"location":"reference/ndv/#ndv.ArrayViewer.display_model","title":"display_model  <code>property</code> <code>writable</code>","text":"<pre><code>display_model: ArrayDisplayModel\n</code></pre> <p>Return the current ArrayDisplayModel.</p>"},{"location":"reference/ndv/#ndv.ArrayViewer.roi","title":"roi  <code>property</code> <code>writable</code>","text":"<pre><code>roi: RectangularROIModel | None\n</code></pre> <p>Return ROI being displayed.</p>"},{"location":"reference/ndv/#ndv.ArrayViewer.clone","title":"clone","text":"<pre><code>clone() -&gt; ArrayViewer\n</code></pre> <p>Return a new ArrayViewer instance with the same data and display model.</p> <p>Currently, this is a shallow copy.  Modifying one viewer will affect the state of the other.</p> Source code in <code>src/ndv/controllers/_array_viewer.py</code> <pre><code>def clone(self) -&gt; ArrayViewer:\n    \"\"\"Return a new ArrayViewer instance with the same data and display model.\n\n    Currently, this is a shallow copy.  Modifying one viewer will affect the state\n    of the other.\n    \"\"\"\n    # TODO: provide deep_copy option\n    return ArrayViewer(\n        self._data_model.data_wrapper, display_model=self.display_model\n    )\n</code></pre>"},{"location":"reference/ndv/#ndv.ArrayViewer.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the viewer.</p> Source code in <code>src/ndv/controllers/_array_viewer.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the viewer.\"\"\"\n    self._view.set_visible(False)\n</code></pre>"},{"location":"reference/ndv/#ndv.ArrayViewer.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Hide the viewer.</p> Source code in <code>src/ndv/controllers/_array_viewer.py</code> <pre><code>def hide(self) -&gt; None:\n    \"\"\"Hide the viewer.\"\"\"\n    self._view.set_visible(False)\n</code></pre>"},{"location":"reference/ndv/#ndv.ArrayViewer.show","title":"show","text":"<pre><code>show() -&gt; None\n</code></pre> <p>Show the viewer.</p> Source code in <code>src/ndv/controllers/_array_viewer.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Show the viewer.\"\"\"\n    self._view.set_visible(True)\n</code></pre>"},{"location":"reference/ndv/#ndv.ArrayViewer.widget","title":"widget","text":"<pre><code>widget() -&gt; Any\n</code></pre> <p>Return the native front-end widget.</p> <p>Warning</p> <p>If you directly manipulate the frontend widget, you're on your own . No guarantees can be made about synchronization with the model.  It is exposed for embedding in an application, and for experimentation and custom use cases.  Please open an issue if you have questions.</p> Source code in <code>src/ndv/controllers/_array_viewer.py</code> <pre><code>def widget(self) -&gt; Any:\n    \"\"\"Return the native front-end widget.\n\n    !!! Warning\n\n        If you directly manipulate the frontend widget, you're on your own :smile:.\n        No guarantees can be made about synchronization with the model.  It is\n        exposed for embedding in an application, and for experimentation and custom\n        use cases.  Please [open an\n        issue](https://github.com/pyapp-kit/ndv/issues/new) if you have questions.\n    \"\"\"\n    return self._view.frontend_widget()\n</code></pre>"},{"location":"reference/ndv/#ndv.DataWrapper","title":"DataWrapper","text":"<pre><code>DataWrapper(data: ArrayT)\n</code></pre> <p>               Bases: <code>Generic[ArrayT]</code>, <code>ABC</code></p> <p>Interface for wrapping different array-like data types.</p> <p><code>DataWrapper.create()</code> is a factory method that returns a <code>DataWrapper</code> instance for the given data type. If your datastore type is not supported, you may implement a new <code>DataWrapper</code> subclass to handle your data type. To do this, import and subclass <code>DataWrapper</code>, and (minimally) implement the supports and isel methods. Ensure that your class is imported before the <code>DataWrapper.create</code> method is called, and it will be automatically detected and used to wrap your data.</p> <p>This base class provides basic support for numpy-like array types.  If the data supports getitem and shape attributes, it will work.  If the data does not support getitem, the subclass MUST implement the <code>isel</code> method.  If the data does not have a <code>shape</code> attribute, the subclass MUST implement the <code>dims</code> and <code>coords</code> properties.</p> <p>Methods:</p> <ul> <li> <code>clear_cache</code>             \u2013              <p>Clear any cached properties.</p> </li> <li> <code>create</code>             \u2013              <p>Create a DataWrapper instance for the given data.</p> </li> <li> <code>guess_channel_axis</code>             \u2013              <p>Return the (best guess) axis name for the channel dimension.</p> </li> <li> <code>guess_z_axis</code>             \u2013              <p>Return the (best guess) axis name for the z (3rd spatial) dimension.</p> </li> <li> <code>isel</code>             \u2013              <p>Return a slice of the data as a numpy array.</p> </li> <li> <code>normalize_axis_key</code>             \u2013              <p>Return positive index for <code>axis</code> (which can be +/- int or str label).</p> </li> <li> <code>sizes</code>             \u2013              <p>Return the sizes of the dimensions.</p> </li> <li> <code>summary_info</code>             \u2013              <p>Return info label with information about the data.</p> </li> <li> <code>supports</code>             \u2013              <p>Return True if this wrapper can handle the given object.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>axis_map</code>               (<code>Mapping[Hashable, int]</code>)           \u2013            <p>Mapping of ALL valid axis keys to normalized, positive integer keys.</p> </li> <li> <code>coords</code>               (<code>Mapping[Hashable, Sequence]</code>)           \u2013            <p>Return the coordinates for the data.</p> </li> <li> <code>data</code>               (<code>ArrayT</code>)           \u2013            <p>Return the data being wrapped.</p> </li> <li> <code>dims</code>               (<code>tuple[Hashable, ...]</code>)           \u2013            <p>Return the dimension labels for the data.</p> </li> <li> <code>dtype</code>               (<code>dtype</code>)           \u2013            <p>Return the dtype for the data.</p> </li> </ul> Source code in <code>src/ndv/models/_data_wrapper.py</code> <pre><code>def __init__(self, data: ArrayT) -&gt; None:\n    self._data = data\n    if not hasattr(self._data, \"__getitem__\") and \"isel\" not in type(self).__dict__:\n        raise NotImplementedError(\n            \"DataWrapper subclass MUST implement `isel` method if data does not \"\n            \"support __getitem__.\"\n        )\n\n    has_shape = hasattr(self._data, \"shape\") and isinstance(self._data.shape, tuple)\n    has_methods = \"dims\" in type(self).__dict__ and \"coords\" in type(self).__dict__\n    if not has_shape and not has_methods:\n        raise NotImplementedError(\n            \"DataWrapper subclass MUST implement `dims` and `coords` properties\"\n            \" if data does not have a `shape` attribute or if the shape is not \"\n            \"a tuple.\"\n        )\n</code></pre>"},{"location":"reference/ndv/#ndv.DataWrapper.axis_map","title":"axis_map  <code>cached</code> <code>property</code>","text":"<pre><code>axis_map: Mapping[Hashable, int]\n</code></pre> <p>Mapping of ALL valid axis keys to normalized, positive integer keys.</p>"},{"location":"reference/ndv/#ndv.DataWrapper.coords","title":"coords  <code>property</code>","text":"<pre><code>coords: Mapping[Hashable, Sequence]\n</code></pre> <p>Return the coordinates for the data.</p>"},{"location":"reference/ndv/#ndv.DataWrapper.data","title":"data  <code>property</code>","text":"<pre><code>data: ArrayT\n</code></pre> <p>Return the data being wrapped.</p>"},{"location":"reference/ndv/#ndv.DataWrapper.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: tuple[Hashable, ...]\n</code></pre> <p>Return the dimension labels for the data.</p>"},{"location":"reference/ndv/#ndv.DataWrapper.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: dtype\n</code></pre> <p>Return the dtype for the data.</p>"},{"location":"reference/ndv/#ndv.DataWrapper.clear_cache","title":"clear_cache","text":"<pre><code>clear_cache() -&gt; None\n</code></pre> <p>Clear any cached properties.</p> Source code in <code>src/ndv/models/_data_wrapper.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear any cached properties.\"\"\"\n    if hasattr(self, \"axis_map\"):\n        del self.axis_map\n</code></pre>"},{"location":"reference/ndv/#ndv.DataWrapper.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(data: ArrayT) -&gt; DataWrapper[ArrayT]\n</code></pre> <p>Create a DataWrapper instance for the given data.</p> <p>This method will detect all subclasses of DataWrapper and check them in order of their <code>PRIORITY</code> class variable. The first subclass that <code>supports</code> the given data will be used to wrap it.</p> <p>Tip</p> <p>This means that you can subclass DataWrapper to handle new data types. Just make sure that your subclass is imported before calling <code>create</code>.</p> <p>If no subclasses support the data, a <code>NotImplementedError</code> is raised.</p> <p>If an instance of <code>DataWrapper</code> is passed in, it will be returned as-is.</p> Source code in <code>src/ndv/models/_data_wrapper.py</code> <pre><code>@classmethod\ndef create(cls, data: ArrayT) -&gt; DataWrapper[ArrayT]:\n    \"\"\"Create a DataWrapper instance for the given data.\n\n    This method will detect all subclasses of DataWrapper and check them in order of\n    their `PRIORITY` class variable. The first subclass that\n    [`supports`][ndv.DataWrapper.supports] the given data will be used to wrap it.\n\n    !!! tip\n\n        This means that you can subclass DataWrapper to handle new data types.\n        Just make sure that your subclass is imported before calling `create`.\n\n    If no subclasses support the data, a `NotImplementedError` is raised.\n\n    If an instance of `DataWrapper` is passed in, it will be returned as-is.\n    \"\"\"\n    if isinstance(data, DataWrapper):\n        return data\n\n    # check subclasses for support\n    # This allows users to define their own DataWrapper subclasses which will\n    # be automatically detected (assuming they have been imported by this point)\n    for subclass in sorted(_recurse_subclasses(cls), key=lambda x: x.PRIORITY):\n        try:\n            if subclass.supports(data):\n                logging.debug(f\"Using {subclass.__name__} to wrap {type(data)}\")\n                return subclass(data)\n        except Exception as e:\n            warnings.warn(\n                f\"Error checking DataWrapper subclass {subclass.__name__}: {e}\",\n                RuntimeWarning,\n                stacklevel=2,\n            )\n    raise NotImplementedError(f\"Don't know how to wrap type {type(data)}\")\n</code></pre>"},{"location":"reference/ndv/#ndv.DataWrapper.guess_channel_axis","title":"guess_channel_axis","text":"<pre><code>guess_channel_axis() -&gt; Hashable | None\n</code></pre> <p>Return the (best guess) axis name for the channel dimension.</p> Source code in <code>src/ndv/models/_data_wrapper.py</code> <pre><code>def guess_channel_axis(self) -&gt; Hashable | None:\n    \"\"\"Return the (best guess) axis name for the channel dimension.\"\"\"\n    # for arrays with labeled dimensions,\n    # see if any of the dimensions are named \"channel\"\n    sizes = self.sizes()\n    for dimkey, val in sizes.items():\n        if str(dimkey).lower() in self.COMMON_CHANNEL_NAMES:\n            if val &lt;= self.MAX_CHANNELS:\n                return self.normalize_axis_key(dimkey)\n\n    # otherwise use the smallest dimension as the channel axis\n    return min(sizes, key=sizes.get)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/ndv/#ndv.DataWrapper.guess_z_axis","title":"guess_z_axis","text":"<pre><code>guess_z_axis() -&gt; Hashable | None\n</code></pre> <p>Return the (best guess) axis name for the z (3rd spatial) dimension.</p> Source code in <code>src/ndv/models/_data_wrapper.py</code> <pre><code>def guess_z_axis(self) -&gt; Hashable | None:\n    \"\"\"Return the (best guess) axis name for the z (3rd spatial) dimension.\"\"\"\n    sizes = self.sizes()\n    ch = self.guess_channel_axis()\n    for dimkey in sizes:\n        if str(dimkey).lower() in self.COMMON_Z_AXIS_NAMES:\n            if (normed := self.normalize_axis_key(dimkey)) != ch:\n                return normed\n\n    # otherwise return the LAST axis that is neither in the last two dimensions\n    # or the channel axis guess\n    return next(\n        (self.normalize_axis_key(x) for x in reversed(self.dims[:-2]) if x != ch),\n        None,\n    )\n</code></pre>"},{"location":"reference/ndv/#ndv.DataWrapper.isel","title":"isel","text":"<pre><code>isel(index: Mapping[int, int | slice]) -&gt; ndarray\n</code></pre> <p>Return a slice of the data as a numpy array.</p> <p><code>index</code> will look like (e.g.) <code>{0: slice(0, 10), 1: 5}</code>. The default implementation converts the index to a tuple of the same length as the self.dims, populating missing keys with <code>slice(None)</code>, and then slices the data array using getitem.</p> Source code in <code>src/ndv/models/_data_wrapper.py</code> <pre><code>def isel(self, index: Mapping[int, int | slice]) -&gt; np.ndarray:\n    \"\"\"Return a slice of the data as a numpy array.\n\n    `index` will look like (e.g.) `{0: slice(0, 10), 1: 5}`.\n    The default implementation converts the index to a tuple of the same length as\n    the self.dims, populating missing keys with `slice(None)`, and then slices the\n    data array using __getitem__.\n    \"\"\"\n    idx = tuple(index.get(k, slice(None)) for k in range(len(self.dims)))\n    # this type ignore is asserted in the __init__ method\n    # if the data does not support __getitem__, then the DataWrapper subclass will\n    # fail to initialize\n    return self._asarray(self._data[idx])  # type: ignore [index]\n</code></pre>"},{"location":"reference/ndv/#ndv.DataWrapper.normalize_axis_key","title":"normalize_axis_key","text":"<pre><code>normalize_axis_key(axis: Hashable) -&gt; int\n</code></pre> <p>Return positive index for <code>axis</code> (which can be +/- int or str label).</p> Source code in <code>src/ndv/models/_data_wrapper.py</code> <pre><code>def normalize_axis_key(self, axis: Hashable) -&gt; int:\n    \"\"\"Return positive index for `axis` (which can be +/- int or str label).\"\"\"\n    try:\n        return self.axis_map[axis]\n    except KeyError as e:\n        ndims = len(self.dims)\n        if isinstance(axis, int):\n            raise IndexError(\n                f\"Axis index {axis} out of bounds for data with {ndims} dimensions\"\n            ) from e\n        raise IndexError(f\"Axis label {axis} not found in data dimensions\") from e\n</code></pre>"},{"location":"reference/ndv/#ndv.DataWrapper.sizes","title":"sizes","text":"<pre><code>sizes() -&gt; Mapping[Hashable, int]\n</code></pre> <p>Return the sizes of the dimensions.</p> Source code in <code>src/ndv/models/_data_wrapper.py</code> <pre><code>def sizes(self) -&gt; Mapping[Hashable, int]:\n    \"\"\"Return the sizes of the dimensions.\"\"\"\n    return {dim: len(self.coords[dim]) for dim in self.dims}\n</code></pre>"},{"location":"reference/ndv/#ndv.DataWrapper.summary_info","title":"summary_info","text":"<pre><code>summary_info() -&gt; str\n</code></pre> <p>Return info label with information about the data.</p> Source code in <code>src/ndv/models/_data_wrapper.py</code> <pre><code>def summary_info(self) -&gt; str:\n    \"\"\"Return info label with information about the data.\"\"\"\n    package = getattr(self._data, \"__module__\", \"\").split(\".\")[0]\n    info = f\"{package}.{getattr(type(self._data), '__qualname__', '')}\"\n\n    if sizes := self.sizes():\n        # if all of the dimension keys are just integers, omit them from size_str\n        if all(isinstance(x, int) for x in sizes):\n            size_str = repr(tuple(sizes.values()))\n        # otherwise, include the keys in the size_str\n        else:\n            size_str = \", \".join(f\"{k}:{v}\" for k, v in sizes.items())\n            size_str = f\"({size_str})\"\n        info += f\" {size_str}\"\n    if dtype := getattr(self._data, \"dtype\", \"\"):\n        info += f\", {dtype}\"\n    if nbytes := getattr(self._data, \"nbytes\", 0):\n        info += f\", {_human_readable_size(nbytes)}\"\n    return info\n</code></pre>"},{"location":"reference/ndv/#ndv.DataWrapper.supports","title":"supports  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>supports(obj: Any) -&gt; TypeGuard[Any]\n</code></pre> <p>Return True if this wrapper can handle the given object.</p> <p>Any exceptions raised by this method will be suppressed, so it is safe to directly import necessary dependencies without a try/except block.</p> Source code in <code>src/ndv/models/_data_wrapper.py</code> <pre><code>@classmethod\n@abstractmethod\ndef supports(cls, obj: Any) -&gt; TypeGuard[Any]:\n    \"\"\"Return True if this wrapper can handle the given object.\n\n    Any exceptions raised by this method will be suppressed, so it is safe to\n    directly import necessary dependencies without a try/except block.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/#ndv.imshow","title":"imshow","text":"<pre><code>imshow(\n    data: Any | DataWrapper,\n    /,\n    display_model: ArrayDisplayModel = ...,\n) -&gt; ArrayViewer\n</code></pre><pre><code>imshow(\n    data: Any | DataWrapper,\n    /,\n    **kwargs: Unpack[ArrayDisplayModelKwargs],\n) -&gt; ArrayViewer\n</code></pre> <pre><code>imshow(\n    data: Any | DataWrapper,\n    /,\n    display_model: ArrayDisplayModel | None = None,\n    **kwargs: Unpack[ArrayDisplayModelKwargs],\n) -&gt; ArrayViewer\n</code></pre> <p>Display an array or DataWrapper in a new <code>ArrayViewer</code> window.</p> <p>This convenience function creates an <code>ArrayViewer</code> instance populated with <code>data</code>, calls <code>show()</code> on it, and then runs the application.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ArrayViewer</code>           \u2013            <p>The <code>ArrayViewer</code> instance.</p> </li> </ul> Source code in <code>src/ndv/util.py</code> <pre><code>def imshow(\n    data: Any | DataWrapper,\n    /,\n    display_model: ArrayDisplayModel | None = None,\n    **kwargs: Unpack[ArrayDisplayModelKwargs],\n) -&gt; ArrayViewer:\n    \"\"\"Display an array or DataWrapper in a new `ArrayViewer` window.\n\n    This convenience function creates an `ArrayViewer` instance populated with `data`,\n    calls `show()` on it, and then runs the application.\n\n    Parameters\n    ----------\n    data : Any | DataWrapper\n        The data to be displayed. Any ArrayLike object or an `ndv.DataWrapper`.\n    display_model: ArrayDisplayModel, optional\n        The display model to use. If not provided, a new one will be created.\n    kwargs : Unpack[ArrayDisplayModelKwargs]\n        Additional keyword arguments used to create the\n        [`ArrayDisplayModel`][ndv.models.ArrayDisplayModel].\n\n    Returns\n    -------\n    ArrayViewer\n        The `ArrayViewer` instance.\n    \"\"\"\n    viewer = ArrayViewer(data, display_model, **kwargs)\n    viewer.show()\n\n    run_app()\n    return viewer\n</code></pre>"},{"location":"reference/ndv/#ndv.imshow(data)","title":"<code>data</code>","text":"(<code>Any | DataWrapper</code>)           \u2013            <p>The data to be displayed. Any ArrayLike object or an <code>ndv.DataWrapper</code>.</p>"},{"location":"reference/ndv/#ndv.imshow(display_model)","title":"<code>display_model</code>","text":"(<code>ArrayDisplayModel | None</code>, default:                   <code>None</code> )           \u2013            <p>The display model to use. If not provided, a new one will be created.</p>"},{"location":"reference/ndv/#ndv.imshow(kwargs)","title":"<code>kwargs</code>","text":"(<code>Unpack[ArrayDisplayModelKwargs]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments used to create the <code>ArrayDisplayModel</code>.</p>"},{"location":"reference/ndv/#ndv.run_app","title":"run_app","text":"<pre><code>run_app() -&gt; None\n</code></pre> <p>Start the active GUI application event loop.</p> Source code in <code>src/ndv/views/_app.py</code> <pre><code>def run_app() -&gt; None:\n    \"\"\"Start the active GUI application event loop.\"\"\"\n    ndv_app().run()\n</code></pre>"},{"location":"reference/ndv/controllers/","title":"ndv.controllers","text":""},{"location":"reference/ndv/controllers/#ndv.controllers","title":"ndv.controllers","text":"<p>Controllers are the primary public interfaces that wrap models &amp; views.</p> <p>Classes:</p> <ul> <li> <code>ArrayViewer</code>           \u2013            <p>Viewer dedicated to displaying a single n-dimensional array.</p> </li> </ul>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer","title":"ArrayViewer","text":"<pre><code>ArrayViewer(\n    data: Any | DataWrapper = None,\n    /,\n    display_model: ArrayDisplayModel | None = None,\n    **kwargs: Unpack[ArrayDisplayModelKwargs],\n)\n</code></pre> <p>Viewer dedicated to displaying a single n-dimensional array.</p> <p>This wraps a model and sview into a single object, and defines the public API.</p> <p>See also</p> <p><code>ndv.imshow</code> - a convenience function that constructs and shows an <code>ArrayViewer</code>.</p> <p>Future plans</p> <p>In the future, <code>ndv</code> would like to support multiple, layered data sources with coordinate transforms. We reserve the name <code>Viewer</code> for a more fully featured viewer. <code>ArrayViewer</code> assumes you're viewing a single array.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>clone</code>             \u2013              <p>Return a new ArrayViewer instance with the same data and display model.</p> </li> <li> <code>close</code>             \u2013              <p>Close the viewer.</p> </li> <li> <code>hide</code>             \u2013              <p>Hide the viewer.</p> </li> <li> <code>show</code>             \u2013              <p>Show the viewer.</p> </li> <li> <code>widget</code>             \u2013              <p>Return the native front-end widget.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>Return data being displayed.</p> </li> <li> <code>data_wrapper</code>               (<code>Any</code>)           \u2013            <p>Return data being displayed.</p> </li> <li> <code>display_model</code>               (<code>ArrayDisplayModel</code>)           \u2013            <p>Return the current ArrayDisplayModel.</p> </li> <li> <code>roi</code>               (<code>RectangularROIModel | None</code>)           \u2013            <p>Return ROI being displayed.</p> </li> </ul> Source code in <code>src/ndv/controllers/_array_viewer.py</code> <pre><code>def __init__(\n    self,\n    data: Any | DataWrapper = None,\n    /,\n    display_model: ArrayDisplayModel | None = None,\n    **kwargs: Unpack[ArrayDisplayModelKwargs],\n) -&gt; None:\n    if display_model is not None and kwargs:\n        warnings.warn(\n            \"When display_model is provided, kwargs are be ignored.\",\n            stacklevel=2,\n        )\n    self._data_model = _ArrayDataDisplayModel(\n        data_wrapper=data, display=display_model or ArrayDisplayModel(**kwargs)\n    )\n    self._viewer_model = ArrayViewerModel()\n    self._viewer_model.events.interaction_mode.connect(\n        self._on_interaction_mode_changed\n    )\n    self._roi_model: RectangularROIModel | None = None\n\n    app = _app.gui_frontend()\n\n    # whether to fetch data asynchronously.  Not publicly exposed yet...\n    # but can use 'NDV_SYNCHRONOUS' env var to set globally\n    # jupyter doesn't need async because it's already async (in that the\n    # GUI is already running in JS)\n    NDV_SYNCHRONOUS = os.getenv(\"NDV_SYNCHRONOUS\", \"0\") in {\"1\", \"True\", \"true\"}\n    self._async = not NDV_SYNCHRONOUS and app != _app.GuiFrontend.JUPYTER\n    # set of futures for data requests\n    self._futures: set[Future[DataResponse]] = set()\n\n    # mapping of channel keys to their respective controllers\n    # where None is the default channel\n    self._lut_controllers: dict[ChannelKey, ChannelController] = {}\n\n    # get and create the front-end and canvas classes\n    frontend_cls = _app.get_array_view_class()\n    canvas_cls = _app.get_array_canvas_class()\n    self._canvas = canvas_cls(self._viewer_model)\n\n    # TODO: Is this necessary?\n    self._histograms: dict[ChannelKey, HistogramCanvas] = {}\n    self._view = frontend_cls(\n        self._canvas.frontend_widget(), self._data_model, self._viewer_model\n    )\n\n    self._roi_view: RectangularROIHandle | None = None\n\n    self._set_model_connected(self._data_model.display)\n    self._canvas.set_ndim(self.display_model.n_visible_axes)\n\n    self._view.currentIndexChanged.connect(self._on_view_current_index_changed)\n    self._view.resetZoomClicked.connect(self._on_view_reset_zoom_clicked)\n    self._view.histogramRequested.connect(self._add_histogram)\n    self._view.channelModeChanged.connect(self._on_view_channel_mode_changed)\n    self._view.visibleAxesChanged.connect(self._on_view_visible_axes_changed)\n\n    self._canvas.mouseMoved.connect(self._on_canvas_mouse_moved)\n\n    if self._data_model.data_wrapper is not None:\n        self._fully_synchronize_view()\n</code></pre>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer(data)","title":"<code>data</code>","text":"(<code> DataWrapper | Any</code>, default:                   <code>None</code> )           \u2013            <p>Data to be displayed.</p>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer(display_model)","title":"<code>display_model</code>","text":"(<code>ArrayDisplayModel</code>, default:                   <code>None</code> )           \u2013            <p>Just the display model to use. If provided, <code>data_or_model</code> must be an array or <code>DataWrapper</code>... and kwargs will be ignored.</p>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Unpack[ArrayDisplayModelKwargs]</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the <code>ArrayDisplayModel</code> constructor. If <code>display_model</code> is provided, these will be ignored.</p>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer.data","title":"data  <code>property</code> <code>writable</code>","text":"<pre><code>data: Any\n</code></pre> <p>Return data being displayed.</p>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer.data_wrapper","title":"data_wrapper  <code>property</code>","text":"<pre><code>data_wrapper: Any\n</code></pre> <p>Return data being displayed.</p>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer.display_model","title":"display_model  <code>property</code> <code>writable</code>","text":"<pre><code>display_model: ArrayDisplayModel\n</code></pre> <p>Return the current ArrayDisplayModel.</p>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer.roi","title":"roi  <code>property</code> <code>writable</code>","text":"<pre><code>roi: RectangularROIModel | None\n</code></pre> <p>Return ROI being displayed.</p>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer.clone","title":"clone","text":"<pre><code>clone() -&gt; ArrayViewer\n</code></pre> <p>Return a new ArrayViewer instance with the same data and display model.</p> <p>Currently, this is a shallow copy.  Modifying one viewer will affect the state of the other.</p> Source code in <code>src/ndv/controllers/_array_viewer.py</code> <pre><code>def clone(self) -&gt; ArrayViewer:\n    \"\"\"Return a new ArrayViewer instance with the same data and display model.\n\n    Currently, this is a shallow copy.  Modifying one viewer will affect the state\n    of the other.\n    \"\"\"\n    # TODO: provide deep_copy option\n    return ArrayViewer(\n        self._data_model.data_wrapper, display_model=self.display_model\n    )\n</code></pre>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the viewer.</p> Source code in <code>src/ndv/controllers/_array_viewer.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the viewer.\"\"\"\n    self._view.set_visible(False)\n</code></pre>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Hide the viewer.</p> Source code in <code>src/ndv/controllers/_array_viewer.py</code> <pre><code>def hide(self) -&gt; None:\n    \"\"\"Hide the viewer.\"\"\"\n    self._view.set_visible(False)\n</code></pre>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer.show","title":"show","text":"<pre><code>show() -&gt; None\n</code></pre> <p>Show the viewer.</p> Source code in <code>src/ndv/controllers/_array_viewer.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Show the viewer.\"\"\"\n    self._view.set_visible(True)\n</code></pre>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer.widget","title":"widget","text":"<pre><code>widget() -&gt; Any\n</code></pre> <p>Return the native front-end widget.</p> <p>Warning</p> <p>If you directly manipulate the frontend widget, you're on your own . No guarantees can be made about synchronization with the model.  It is exposed for embedding in an application, and for experimentation and custom use cases.  Please open an issue if you have questions.</p> Source code in <code>src/ndv/controllers/_array_viewer.py</code> <pre><code>def widget(self) -&gt; Any:\n    \"\"\"Return the native front-end widget.\n\n    !!! Warning\n\n        If you directly manipulate the frontend widget, you're on your own :smile:.\n        No guarantees can be made about synchronization with the model.  It is\n        exposed for embedding in an application, and for experimentation and custom\n        use cases.  Please [open an\n        issue](https://github.com/pyapp-kit/ndv/issues/new) if you have questions.\n    \"\"\"\n    return self._view.frontend_widget()\n</code></pre>"},{"location":"reference/ndv/data/","title":"ndv.data","text":""},{"location":"reference/ndv/data/#ndv.data","title":"ndv.data","text":"<p>Sample data for testing and examples.</p> <p>Functions:</p> <ul> <li> <code>astronaut</code>             \u2013              <p>Load RGB data <code>(512, 512, 3)</code>, uint8.</p> </li> <li> <code>cat</code>             \u2013              <p>Load RGB cat data <code>(300, 451, 3)</code>, uint8.</p> </li> <li> <code>cells3d</code>             \u2013              <p>Load cells3d from scikit-image <code>(60, 2, 256, 256)</code> uint16.</p> </li> <li> <code>cosem_dataset</code>             \u2013              <p>Load a dataset from the COSEM/OpenOrganelle project.</p> </li> <li> <code>nd_sine_wave</code>             \u2013              <p>5D dataset: <code>(10, 3, 5, 512, 512)</code>, float64.</p> </li> </ul>"},{"location":"reference/ndv/data/#ndv.data.astronaut","title":"astronaut","text":"<pre><code>astronaut() -&gt; ndarray\n</code></pre> <p>Load RGB data <code>(512, 512, 3)</code>, uint8.</p> <p>Requires imageio to be installed.</p> Source code in <code>src/ndv/data.py</code> <pre><code>def astronaut() -&gt; np.ndarray:\n    \"\"\"Load RGB data `(512, 512, 3)`, uint8.\n\n    Requires [imageio](https://pypi.org/project/imageio/) to be installed.\n    \"\"\"\n    return _imread(\"imageio:astronaut.png\")\n</code></pre>"},{"location":"reference/ndv/data/#ndv.data.cat","title":"cat","text":"<pre><code>cat() -&gt; ndarray\n</code></pre> <p>Load RGB cat data <code>(300, 451, 3)</code>, uint8.</p> <p>Requires imageio to be installed.</p> Source code in <code>src/ndv/data.py</code> <pre><code>def cat() -&gt; np.ndarray:\n    \"\"\"Load RGB cat data `(300, 451, 3)`, uint8.\n\n    Requires [imageio](https://pypi.org/project/imageio/) to be installed.\n    \"\"\"\n    return _imread(\"imageio:chelsea.png\")\n</code></pre>"},{"location":"reference/ndv/data/#ndv.data.cells3d","title":"cells3d","text":"<pre><code>cells3d() -&gt; ndarray\n</code></pre> <p>Load cells3d from scikit-image <code>(60, 2, 256, 256)</code> uint16.</p> <p>Requires <code>imageio and tifffile</code> to be installed.</p> Source code in <code>src/ndv/data.py</code> <pre><code>def cells3d() -&gt; np.ndarray:\n    \"\"\"Load cells3d from scikit-image `(60, 2, 256, 256)` uint16.\n\n    Requires `imageio and tifffile` to be installed.\n    \"\"\"\n    try:\n        from imageio.v2 import volread\n    except ImportError as e:\n        raise ImportError(\n            \"Please `pip install imageio[tifffile]` to load cells3d\"\n        ) from e\n\n    url = \"https://gitlab.com/scikit-image/data/-/raw/2cdc5ce89b334d28f06a58c9f0ca21aa6992a5ba/cells3d.tif\"\n    data = np.asarray(volread(url))\n\n    # this data has been stretched to 16 bit, and lacks certain intensity values\n    # add a small random integer to each pixel ... so the histogram is not silly\n    data = (data + np.random.randint(-24, 24, data.shape)).clip(0, 65535)\n    return data.astype(np.uint16)\n</code></pre>"},{"location":"reference/ndv/data/#ndv.data.cosem_dataset","title":"cosem_dataset","text":"<pre><code>cosem_dataset(\n    uri: str = \"\",\n    dataset: str = \"jrc_hela-3\",\n    label: str = \"er-mem_pred\",\n    level: int = 4,\n) -&gt; Any\n</code></pre> <p>Load a dataset from the COSEM/OpenOrganelle project.</p> <p>Search for available options at: https://openorganelle.janelia.org/datasets</p> <p>Requires tensorstore to be installed.</p> <p>Parameters:</p> Source code in <code>src/ndv/data.py</code> <pre><code>def cosem_dataset(\n    uri: str = \"\",\n    dataset: str = \"jrc_hela-3\",\n    label: str = \"er-mem_pred\",\n    level: int = 4,\n) -&gt; Any:\n    \"\"\"Load a dataset from the COSEM/OpenOrganelle project.\n\n    Search for available options at: &lt;https://openorganelle.janelia.org/datasets&gt;\n\n    Requires [tensorstore](https://pypi.org/project/tensorstore/) to be installed.\n\n    Parameters\n    ----------\n    uri : str, optional\n        The URI of the dataset to load. If not provided, the default URI is\n        `f\"{dataset}/{dataset}.n5/labels/{label}/s{level}/\"`.\n    dataset : str, optional\n        The name of the dataset to load. Default is \"jrc_hela-3\".\n    label : str, optional\n        The label to load. Default is \"er-mem_pred\".\n    level : int, optional\n        The pyramid level to load. Default is 4.\n    \"\"\"\n    try:\n        import tensorstore as ts\n    except ImportError:\n        raise ImportError(\"Please install tensorstore to fetch cosem data\") from None\n\n    if not uri:\n        uri = f\"{dataset}/{dataset}.n5/labels/{label}/s{level}/\"\n\n    ts_array = ts.open(\n        {\n            \"driver\": \"n5\",\n            \"kvstore\": {\n                \"driver\": \"s3\",\n                \"bucket\": \"janelia-cosem-datasets\",\n                \"path\": uri,\n            },\n            # 1GB cache... but i don't think it's working\n            \"cache_pool\": {\"total_bytes_limit\": 1e9},\n        },\n    ).result()\n    ts_array = ts_array[ts.d[:].label[\"z\", \"y\", \"x\"]]\n    return ts_array[ts.d[(\"y\", \"x\", \"z\")].transpose[:]]\n</code></pre>"},{"location":"reference/ndv/data/#ndv.data.cosem_dataset(uri)","title":"<code>uri</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The URI of the dataset to load. If not provided, the default URI is <code>f\"{dataset}/{dataset}.n5/labels/{label}/s{level}/\"</code>.</p>"},{"location":"reference/ndv/data/#ndv.data.cosem_dataset(dataset)","title":"<code>dataset</code>","text":"(<code>str</code>, default:                   <code>'jrc_hela-3'</code> )           \u2013            <p>The name of the dataset to load. Default is \"jrc_hela-3\".</p>"},{"location":"reference/ndv/data/#ndv.data.cosem_dataset(label)","title":"<code>label</code>","text":"(<code>str</code>, default:                   <code>'er-mem_pred'</code> )           \u2013            <p>The label to load. Default is \"er-mem_pred\".</p>"},{"location":"reference/ndv/data/#ndv.data.cosem_dataset(level)","title":"<code>level</code>","text":"(<code>int</code>, default:                   <code>4</code> )           \u2013            <p>The pyramid level to load. Default is 4.</p>"},{"location":"reference/ndv/data/#ndv.data.nd_sine_wave","title":"nd_sine_wave","text":"<pre><code>nd_sine_wave(\n    shape: tuple[int, int, int, int, int] = (\n        10,\n        3,\n        5,\n        512,\n        512,\n    ),\n    amplitude: float = 240,\n    base_frequency: float = 5,\n) -&gt; ndarray\n</code></pre> <p>5D dataset: <code>(10, 3, 5, 512, 512)</code>, float64.</p> Source code in <code>src/ndv/data.py</code> <pre><code>def nd_sine_wave(\n    shape: tuple[int, int, int, int, int] = (10, 3, 5, 512, 512),\n    amplitude: float = 240,\n    base_frequency: float = 5,\n) -&gt; np.ndarray:\n    \"\"\"5D dataset: `(10, 3, 5, 512, 512)`, float64.\"\"\"\n    # Unpack the dimensions\n    if not len(shape) == 5:\n        raise ValueError(\"Shape must have 5 dimensions\")\n    angle_dim, freq_dim, phase_dim, ny, nx = shape\n\n    # Create an empty array to hold the data\n    output = np.zeros(shape)\n\n    # Define spatial coordinates for the last two dimensions\n    half_per = base_frequency * np.pi\n    x = np.linspace(-half_per, half_per, nx)\n    y = np.linspace(-half_per, half_per, ny)\n    y, x = np.meshgrid(y, x)\n\n    # Iterate through each parameter in the higher dimensions\n    for phase_idx in range(phase_dim):\n        for freq_idx in range(freq_dim):\n            for angle_idx in range(angle_dim):\n                # Calculate phase and frequency\n                phase = np.pi / phase_dim * phase_idx\n                frequency = 1 + (freq_idx * 0.1)  # Increasing frequency with each step\n\n                # Calculate angle\n                angle = np.pi / angle_dim * angle_idx\n                # Rotate x and y coordinates\n                xr = np.cos(angle) * x - np.sin(angle) * y\n                np.sin(angle) * x + np.cos(angle) * y\n\n                # Compute the sine wave\n                sine_wave = (amplitude * 0.5) * np.sin(frequency * xr + phase)\n                sine_wave += amplitude * 0.5\n\n                # Assign to the output array\n                output[angle_idx, freq_idx, phase_idx] = sine_wave\n\n    return output.astype(np.float32)\n</code></pre>"},{"location":"reference/ndv/models/","title":"ndv.models","text":""},{"location":"reference/ndv/models/#ndv.models","title":"ndv.models","text":"<p>Models for <code>ndv</code>.</p> <p>Classes:</p> <ul> <li> <code>ArrayDisplayModel</code>           \u2013            <p>Model of how to display an array.</p> </li> <li> <code>ChannelMode</code>           \u2013            <p>Channel display mode.</p> </li> <li> <code>ClimPolicy</code>           \u2013            <p>ABC for contrast limit policies.</p> </li> <li> <code>ClimsManual</code>           \u2013            <p>Manually specified contrast limits.</p> </li> <li> <code>ClimsMinMax</code>           \u2013            <p>Autoscale contrast limits based on the minimum and maximum values in the data.</p> </li> <li> <code>ClimsPercentile</code>           \u2013            <p>Autoscale contrast limits based on percentiles of the data.</p> </li> <li> <code>ClimsStdDev</code>           \u2013            <p>Automatically set contrast limits based on standard deviations from the mean.</p> </li> <li> <code>DataWrapper</code>           \u2013            <p>Interface for wrapping different array-like data types.</p> </li> <li> <code>LUTModel</code>           \u2013            <p>Representation of how to display a channel of an array.</p> </li> <li> <code>NDVModel</code>           \u2013            <p>Base evented model for NDV models.</p> </li> <li> <code>RectangularROIModel</code>           \u2013            <p>Representation of an axis-aligned rectangular Region of Interest (ROI).</p> </li> </ul>"},{"location":"reference/ndv/models/#ndv.models.ArrayDisplayModel","title":"ArrayDisplayModel","text":"<p>               Bases: <code>NDVModel</code></p> <p>Model of how to display an array.</p> <p>An <code>ArrayDisplayModel</code> is used to specify how to display a multi-dimensional array. It specifies which axes are visible, how to reduce along axes that are not visible, how to display channels, and how to apply lookup tables to channels.  It is typically paired with a <code>ndv.DataWrapper</code> in order to resolve axis keys and slice data.</p> <p>Info</p> <p>In the following types, <code>Hashable</code> is used to refer to a type that will typically be either an integer index or a string label for an axis.</p> <p>Attributes:</p> <ul> <li> <code>visible_axes</code>               (<code>tuple[Hashable, ...]</code>)           \u2013            <p>Ordered list of axes to visualize, from slowest to fastest. e.g. <code>('Z', -2, -1)</code></p> </li> <li> <code>current_index</code>               (<code>Mapping[Hashable, int | slice]</code>)           \u2013            <p>The currently displayed position/slice along each dimension. e.g. {0: 0, 'time': slice(10, 20)} Not all axes need be present, and axes not present are assumed to be slice(None), meaning it is up to the controller of this model to restrict indices to an efficient range for retrieval. If the number of non-singleton axes is greater than <code>n_visible_axes</code>, then <code>reducers</code> are used to reduce the data along the remaining axes.</p> </li> <li> <code>reducers</code>               (<code>Mapping[Hashable | None, ufunc]</code>)           \u2013            <p>Function used to reduce data along axes remaining after slicing. Ideally, the ufunc should accept an <code>axis</code> argument. (TODO: what happens if not?)</p> </li> <li> <code>default_reducer</code>               (<code>ufunc</code>)           \u2013            <p>Default reducer to use when no reducer is specified for an axis. By default, this is <code>numpy.max</code>.</p> </li> <li> <code>channel_mode</code>               (<code>ChannelMode</code>)           \u2013            <p>How to display channel information:</p> <ul> <li><code>GRAYSCALE</code>: ignore channel axis, use <code>default_lut</code></li> <li><code>COMPOSITE</code>: display all channels as a composite image, using <code>luts</code></li> <li><code>COLOR</code>: display a single channel at a time, using <code>luts</code></li> <li><code>RGBA</code>: display as an RGB image, using <code>default_lut</code> (except for cmap)</li> </ul> <p>If <code>channel_mode</code> is set to anything other than <code>GRAYSCALE</code>, then <code>channel_axis</code> must be set to a valid axis; if no <code>channel_axis</code> is set, at the time of display, the <code>DataWrapper</code> MAY guess the <code>channel_axis</code>, and set it on the model.</p> </li> <li> <code>channel_axis</code>               (<code>Hashable | None</code>)           \u2013            <p>The dimension index or name of the channel dimension. The implication of setting channel_axis is that all elements along the channel dimension are shown, with different LUTs applied to each channel. If None, then a single lookup table is used for all channels (<code>luts[None]</code>). NOTE: it is an error for channel_axis to be in <code>visible_axes</code> (or ignore it?)</p> </li> <li> <code>luts</code>               (<code>Mapping[int | None, LUTModel]</code>)           \u2013            <p>Instructions for how to display each channel of the array. Keys represent position along the dimension specified by <code>channel_axis</code>. Values are <code>LUT</code> objects that specify how to display the channel. The special key <code>None</code> is used to represent a fallback LUT for all channels, and is used when <code>channel_axis</code> is None.  It should always be present</p> </li> <li> <code>default_lut</code>               (<code>LUTModel</code>)           \u2013            <p>Default lookup table to use when no <code>LUTModel</code> is specified for a channel in <code>luts</code>.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>n_visible_axes</code>               (<code>Literal[2, 3]</code>)           \u2013            <p>Number of dims is derived from the length of <code>visible_axes</code>.</p> </li> </ul>"},{"location":"reference/ndv/models/#ndv.models.ArrayDisplayModel.n_visible_axes","title":"n_visible_axes  <code>property</code>","text":"<pre><code>n_visible_axes: Literal[2, 3]\n</code></pre> <p>Number of dims is derived from the length of <code>visible_axes</code>.</p>"},{"location":"reference/ndv/models/#ndv.models.ChannelMode","title":"ChannelMode","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Channel display mode.</p> <p>Attributes:</p> <ul> <li> <code>GRAYSCALE</code>               (<code>str</code>)           \u2013            <p>The array is displayed as a single channel, with a single lookup table applied. In this mode, there effective is no channel axis: all non-visible dimensions have sliders, and there is a single LUT control (the <code>default_lut</code>).</p> </li> <li> <code>COMPOSITE</code>               (<code>str</code>)           \u2013            <p>Display all (or a subset of) channels as a composite image, with a different lookup table applied to each channel.  In this mode, the slider for the channel axis is hidden by default, and LUT controls for each channel are shown.</p> </li> <li> <code>COLOR</code>               (<code>str</code>)           \u2013            <p>Display a single channel at a time as a color image, with a channel-specific lookup table applied.  In this mode, the slider for the channel axis is shown, and the user can select which channel to display.  LUT controls are shown for all channels.</p> </li> <li> <code>RGBA</code>               (<code>str</code>)           \u2013            <p>The array is displayed as an RGB image, with a single lookup table applied. In this mode, the slider for the channel axis is hidden, and a single LUT control is shown. Only valid when channel axis has length &lt;= 4.</p> </li> <li> <code>RGB</code>               (<code>str</code>)           \u2013            <p>Alias for RGBA.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>is_multichannel</code>             \u2013              <p>Return whether this mode displays multiple channels.</p> </li> </ul>"},{"location":"reference/ndv/models/#ndv.models.ChannelMode.is_multichannel","title":"is_multichannel","text":"<pre><code>is_multichannel() -&gt; bool\n</code></pre> <p>Return whether this mode displays multiple channels.</p> <p>If <code>is_multichannel</code> is True, then the <code>channel_axis</code> slider should be hidden.</p> Source code in <code>src/ndv/models/_array_display_model.py</code> <pre><code>def is_multichannel(self) -&gt; bool:\n    \"\"\"Return whether this mode displays multiple channels.\n\n    If `is_multichannel` is True, then the `channel_axis` slider should be hidden.\n    \"\"\"\n    return self in (ChannelMode.COMPOSITE, ChannelMode.RGBA)\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.ClimPolicy","title":"ClimPolicy","text":"<p>               Bases: <code>BaseModel</code>, <code>ABC</code></p> <p>ABC for contrast limit policies.</p> <p>Methods:</p> <ul> <li> <code>get_limits</code>             \u2013              <p>Return the contrast limits for the given image.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>cached_clims</code>               (<code>Optional[tuple[float, float]]</code>)           \u2013            <p>Return the last calculated clims.</p> </li> </ul>"},{"location":"reference/ndv/models/#ndv.models.ClimPolicy.cached_clims","title":"cached_clims  <code>property</code>","text":"<pre><code>cached_clims: Optional[tuple[float, float]]\n</code></pre> <p>Return the last calculated clims.</p>"},{"location":"reference/ndv/models/#ndv.models.ClimPolicy.get_limits","title":"get_limits  <code>abstractmethod</code>","text":"<pre><code>get_limits(image: NDArray) -&gt; tuple[float, float]\n</code></pre> <p>Return the contrast limits for the given image.</p> Source code in <code>src/ndv/models/_lut_model.py</code> <pre><code>@abstractmethod\ndef get_limits(self, image: npt.NDArray) -&gt; tuple[float, float]:\n    \"\"\"Return the contrast limits for the given image.\"\"\"\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.ClimsManual","title":"ClimsManual","text":"<p>               Bases: <code>ClimPolicy</code></p> <p>Manually specified contrast limits.</p> <p>Attributes:</p> <ul> <li> <code>min</code>               (<code>float</code>)           \u2013            <p>The minimum contrast limit.</p> </li> <li> <code>max</code>               (<code>float</code>)           \u2013            <p>The maximum contrast limit.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>cached_clims</code>               (<code>Optional[tuple[float, float]]</code>)           \u2013            <p>Return the last calculated clims.</p> </li> </ul>"},{"location":"reference/ndv/models/#ndv.models.ClimsManual.cached_clims","title":"cached_clims  <code>property</code>","text":"<pre><code>cached_clims: Optional[tuple[float, float]]\n</code></pre> <p>Return the last calculated clims.</p>"},{"location":"reference/ndv/models/#ndv.models.ClimsMinMax","title":"ClimsMinMax","text":"<p>               Bases: <code>ClimPolicy</code></p> <p>Autoscale contrast limits based on the minimum and maximum values in the data.</p> <p>Attributes:</p> <ul> <li> <code>cached_clims</code>               (<code>Optional[tuple[float, float]]</code>)           \u2013            <p>Return the last calculated clims.</p> </li> </ul>"},{"location":"reference/ndv/models/#ndv.models.ClimsMinMax.cached_clims","title":"cached_clims  <code>property</code>","text":"<pre><code>cached_clims: Optional[tuple[float, float]]\n</code></pre> <p>Return the last calculated clims.</p>"},{"location":"reference/ndv/models/#ndv.models.ClimsPercentile","title":"ClimsPercentile","text":"<p>               Bases: <code>ClimPolicy</code></p> <p>Autoscale contrast limits based on percentiles of the data.</p> <p>Attributes:</p> <ul> <li> <code>min_percentile</code>               (<code>float</code>)           \u2013            <p>The lower percentile for the contrast limits.</p> </li> <li> <code>max_percentile</code>               (<code>float</code>)           \u2013            <p>The upper percentile for the contrast limits.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>cached_clims</code>               (<code>Optional[tuple[float, float]]</code>)           \u2013            <p>Return the last calculated clims.</p> </li> </ul>"},{"location":"reference/ndv/models/#ndv.models.ClimsPercentile.cached_clims","title":"cached_clims  <code>property</code>","text":"<pre><code>cached_clims: Optional[tuple[float, float]]\n</code></pre> <p>Return the last calculated clims.</p>"},{"location":"reference/ndv/models/#ndv.models.ClimsStdDev","title":"ClimsStdDev","text":"<p>               Bases: <code>ClimPolicy</code></p> <p>Automatically set contrast limits based on standard deviations from the mean.</p> <p>Attributes:</p> <ul> <li> <code>n_stdev</code>               (<code>float</code>)           \u2013            <p>Number of standard deviations to use.</p> </li> <li> <code>center</code>               (<code>Optional[float]</code>)           \u2013            <p>Center value for the standard deviation calculation. If None, the mean is used.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>cached_clims</code>               (<code>Optional[tuple[float, float]]</code>)           \u2013            <p>Return the last calculated clims.</p> </li> </ul>"},{"location":"reference/ndv/models/#ndv.models.ClimsStdDev.cached_clims","title":"cached_clims  <code>property</code>","text":"<pre><code>cached_clims: Optional[tuple[float, float]]\n</code></pre> <p>Return the last calculated clims.</p>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper","title":"DataWrapper","text":"<pre><code>DataWrapper(data: ArrayT)\n</code></pre> <p>               Bases: <code>Generic[ArrayT]</code>, <code>ABC</code></p> <p>Interface for wrapping different array-like data types.</p> <p><code>DataWrapper.create()</code> is a factory method that returns a <code>DataWrapper</code> instance for the given data type. If your datastore type is not supported, you may implement a new <code>DataWrapper</code> subclass to handle your data type. To do this, import and subclass <code>DataWrapper</code>, and (minimally) implement the supports and isel methods. Ensure that your class is imported before the <code>DataWrapper.create</code> method is called, and it will be automatically detected and used to wrap your data.</p> <p>This base class provides basic support for numpy-like array types.  If the data supports getitem and shape attributes, it will work.  If the data does not support getitem, the subclass MUST implement the <code>isel</code> method.  If the data does not have a <code>shape</code> attribute, the subclass MUST implement the <code>dims</code> and <code>coords</code> properties.</p> <p>Methods:</p> <ul> <li> <code>clear_cache</code>             \u2013              <p>Clear any cached properties.</p> </li> <li> <code>create</code>             \u2013              <p>Create a DataWrapper instance for the given data.</p> </li> <li> <code>guess_channel_axis</code>             \u2013              <p>Return the (best guess) axis name for the channel dimension.</p> </li> <li> <code>guess_z_axis</code>             \u2013              <p>Return the (best guess) axis name for the z (3rd spatial) dimension.</p> </li> <li> <code>isel</code>             \u2013              <p>Return a slice of the data as a numpy array.</p> </li> <li> <code>normalize_axis_key</code>             \u2013              <p>Return positive index for <code>axis</code> (which can be +/- int or str label).</p> </li> <li> <code>sizes</code>             \u2013              <p>Return the sizes of the dimensions.</p> </li> <li> <code>summary_info</code>             \u2013              <p>Return info label with information about the data.</p> </li> <li> <code>supports</code>             \u2013              <p>Return True if this wrapper can handle the given object.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>axis_map</code>               (<code>Mapping[Hashable, int]</code>)           \u2013            <p>Mapping of ALL valid axis keys to normalized, positive integer keys.</p> </li> <li> <code>coords</code>               (<code>Mapping[Hashable, Sequence]</code>)           \u2013            <p>Return the coordinates for the data.</p> </li> <li> <code>data</code>               (<code>ArrayT</code>)           \u2013            <p>Return the data being wrapped.</p> </li> <li> <code>dims</code>               (<code>tuple[Hashable, ...]</code>)           \u2013            <p>Return the dimension labels for the data.</p> </li> <li> <code>dtype</code>               (<code>dtype</code>)           \u2013            <p>Return the dtype for the data.</p> </li> </ul> Source code in <code>src/ndv/models/_data_wrapper.py</code> <pre><code>def __init__(self, data: ArrayT) -&gt; None:\n    self._data = data\n    if not hasattr(self._data, \"__getitem__\") and \"isel\" not in type(self).__dict__:\n        raise NotImplementedError(\n            \"DataWrapper subclass MUST implement `isel` method if data does not \"\n            \"support __getitem__.\"\n        )\n\n    has_shape = hasattr(self._data, \"shape\") and isinstance(self._data.shape, tuple)\n    has_methods = \"dims\" in type(self).__dict__ and \"coords\" in type(self).__dict__\n    if not has_shape and not has_methods:\n        raise NotImplementedError(\n            \"DataWrapper subclass MUST implement `dims` and `coords` properties\"\n            \" if data does not have a `shape` attribute or if the shape is not \"\n            \"a tuple.\"\n        )\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.axis_map","title":"axis_map  <code>cached</code> <code>property</code>","text":"<pre><code>axis_map: Mapping[Hashable, int]\n</code></pre> <p>Mapping of ALL valid axis keys to normalized, positive integer keys.</p>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.coords","title":"coords  <code>property</code>","text":"<pre><code>coords: Mapping[Hashable, Sequence]\n</code></pre> <p>Return the coordinates for the data.</p>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.data","title":"data  <code>property</code>","text":"<pre><code>data: ArrayT\n</code></pre> <p>Return the data being wrapped.</p>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: tuple[Hashable, ...]\n</code></pre> <p>Return the dimension labels for the data.</p>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: dtype\n</code></pre> <p>Return the dtype for the data.</p>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.clear_cache","title":"clear_cache","text":"<pre><code>clear_cache() -&gt; None\n</code></pre> <p>Clear any cached properties.</p> Source code in <code>src/ndv/models/_data_wrapper.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear any cached properties.\"\"\"\n    if hasattr(self, \"axis_map\"):\n        del self.axis_map\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(data: ArrayT) -&gt; DataWrapper[ArrayT]\n</code></pre> <p>Create a DataWrapper instance for the given data.</p> <p>This method will detect all subclasses of DataWrapper and check them in order of their <code>PRIORITY</code> class variable. The first subclass that <code>supports</code> the given data will be used to wrap it.</p> <p>Tip</p> <p>This means that you can subclass DataWrapper to handle new data types. Just make sure that your subclass is imported before calling <code>create</code>.</p> <p>If no subclasses support the data, a <code>NotImplementedError</code> is raised.</p> <p>If an instance of <code>DataWrapper</code> is passed in, it will be returned as-is.</p> Source code in <code>src/ndv/models/_data_wrapper.py</code> <pre><code>@classmethod\ndef create(cls, data: ArrayT) -&gt; DataWrapper[ArrayT]:\n    \"\"\"Create a DataWrapper instance for the given data.\n\n    This method will detect all subclasses of DataWrapper and check them in order of\n    their `PRIORITY` class variable. The first subclass that\n    [`supports`][ndv.DataWrapper.supports] the given data will be used to wrap it.\n\n    !!! tip\n\n        This means that you can subclass DataWrapper to handle new data types.\n        Just make sure that your subclass is imported before calling `create`.\n\n    If no subclasses support the data, a `NotImplementedError` is raised.\n\n    If an instance of `DataWrapper` is passed in, it will be returned as-is.\n    \"\"\"\n    if isinstance(data, DataWrapper):\n        return data\n\n    # check subclasses for support\n    # This allows users to define their own DataWrapper subclasses which will\n    # be automatically detected (assuming they have been imported by this point)\n    for subclass in sorted(_recurse_subclasses(cls), key=lambda x: x.PRIORITY):\n        try:\n            if subclass.supports(data):\n                logging.debug(f\"Using {subclass.__name__} to wrap {type(data)}\")\n                return subclass(data)\n        except Exception as e:\n            warnings.warn(\n                f\"Error checking DataWrapper subclass {subclass.__name__}: {e}\",\n                RuntimeWarning,\n                stacklevel=2,\n            )\n    raise NotImplementedError(f\"Don't know how to wrap type {type(data)}\")\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.guess_channel_axis","title":"guess_channel_axis","text":"<pre><code>guess_channel_axis() -&gt; Hashable | None\n</code></pre> <p>Return the (best guess) axis name for the channel dimension.</p> Source code in <code>src/ndv/models/_data_wrapper.py</code> <pre><code>def guess_channel_axis(self) -&gt; Hashable | None:\n    \"\"\"Return the (best guess) axis name for the channel dimension.\"\"\"\n    # for arrays with labeled dimensions,\n    # see if any of the dimensions are named \"channel\"\n    sizes = self.sizes()\n    for dimkey, val in sizes.items():\n        if str(dimkey).lower() in self.COMMON_CHANNEL_NAMES:\n            if val &lt;= self.MAX_CHANNELS:\n                return self.normalize_axis_key(dimkey)\n\n    # otherwise use the smallest dimension as the channel axis\n    return min(sizes, key=sizes.get)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.guess_z_axis","title":"guess_z_axis","text":"<pre><code>guess_z_axis() -&gt; Hashable | None\n</code></pre> <p>Return the (best guess) axis name for the z (3rd spatial) dimension.</p> Source code in <code>src/ndv/models/_data_wrapper.py</code> <pre><code>def guess_z_axis(self) -&gt; Hashable | None:\n    \"\"\"Return the (best guess) axis name for the z (3rd spatial) dimension.\"\"\"\n    sizes = self.sizes()\n    ch = self.guess_channel_axis()\n    for dimkey in sizes:\n        if str(dimkey).lower() in self.COMMON_Z_AXIS_NAMES:\n            if (normed := self.normalize_axis_key(dimkey)) != ch:\n                return normed\n\n    # otherwise return the LAST axis that is neither in the last two dimensions\n    # or the channel axis guess\n    return next(\n        (self.normalize_axis_key(x) for x in reversed(self.dims[:-2]) if x != ch),\n        None,\n    )\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.isel","title":"isel","text":"<pre><code>isel(index: Mapping[int, int | slice]) -&gt; ndarray\n</code></pre> <p>Return a slice of the data as a numpy array.</p> <p><code>index</code> will look like (e.g.) <code>{0: slice(0, 10), 1: 5}</code>. The default implementation converts the index to a tuple of the same length as the self.dims, populating missing keys with <code>slice(None)</code>, and then slices the data array using getitem.</p> Source code in <code>src/ndv/models/_data_wrapper.py</code> <pre><code>def isel(self, index: Mapping[int, int | slice]) -&gt; np.ndarray:\n    \"\"\"Return a slice of the data as a numpy array.\n\n    `index` will look like (e.g.) `{0: slice(0, 10), 1: 5}`.\n    The default implementation converts the index to a tuple of the same length as\n    the self.dims, populating missing keys with `slice(None)`, and then slices the\n    data array using __getitem__.\n    \"\"\"\n    idx = tuple(index.get(k, slice(None)) for k in range(len(self.dims)))\n    # this type ignore is asserted in the __init__ method\n    # if the data does not support __getitem__, then the DataWrapper subclass will\n    # fail to initialize\n    return self._asarray(self._data[idx])  # type: ignore [index]\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.normalize_axis_key","title":"normalize_axis_key","text":"<pre><code>normalize_axis_key(axis: Hashable) -&gt; int\n</code></pre> <p>Return positive index for <code>axis</code> (which can be +/- int or str label).</p> Source code in <code>src/ndv/models/_data_wrapper.py</code> <pre><code>def normalize_axis_key(self, axis: Hashable) -&gt; int:\n    \"\"\"Return positive index for `axis` (which can be +/- int or str label).\"\"\"\n    try:\n        return self.axis_map[axis]\n    except KeyError as e:\n        ndims = len(self.dims)\n        if isinstance(axis, int):\n            raise IndexError(\n                f\"Axis index {axis} out of bounds for data with {ndims} dimensions\"\n            ) from e\n        raise IndexError(f\"Axis label {axis} not found in data dimensions\") from e\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.sizes","title":"sizes","text":"<pre><code>sizes() -&gt; Mapping[Hashable, int]\n</code></pre> <p>Return the sizes of the dimensions.</p> Source code in <code>src/ndv/models/_data_wrapper.py</code> <pre><code>def sizes(self) -&gt; Mapping[Hashable, int]:\n    \"\"\"Return the sizes of the dimensions.\"\"\"\n    return {dim: len(self.coords[dim]) for dim in self.dims}\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.summary_info","title":"summary_info","text":"<pre><code>summary_info() -&gt; str\n</code></pre> <p>Return info label with information about the data.</p> Source code in <code>src/ndv/models/_data_wrapper.py</code> <pre><code>def summary_info(self) -&gt; str:\n    \"\"\"Return info label with information about the data.\"\"\"\n    package = getattr(self._data, \"__module__\", \"\").split(\".\")[0]\n    info = f\"{package}.{getattr(type(self._data), '__qualname__', '')}\"\n\n    if sizes := self.sizes():\n        # if all of the dimension keys are just integers, omit them from size_str\n        if all(isinstance(x, int) for x in sizes):\n            size_str = repr(tuple(sizes.values()))\n        # otherwise, include the keys in the size_str\n        else:\n            size_str = \", \".join(f\"{k}:{v}\" for k, v in sizes.items())\n            size_str = f\"({size_str})\"\n        info += f\" {size_str}\"\n    if dtype := getattr(self._data, \"dtype\", \"\"):\n        info += f\", {dtype}\"\n    if nbytes := getattr(self._data, \"nbytes\", 0):\n        info += f\", {_human_readable_size(nbytes)}\"\n    return info\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.supports","title":"supports  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>supports(obj: Any) -&gt; TypeGuard[Any]\n</code></pre> <p>Return True if this wrapper can handle the given object.</p> <p>Any exceptions raised by this method will be suppressed, so it is safe to directly import necessary dependencies without a try/except block.</p> Source code in <code>src/ndv/models/_data_wrapper.py</code> <pre><code>@classmethod\n@abstractmethod\ndef supports(cls, obj: Any) -&gt; TypeGuard[Any]:\n    \"\"\"Return True if this wrapper can handle the given object.\n\n    Any exceptions raised by this method will be suppressed, so it is safe to\n    directly import necessary dependencies without a try/except block.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.LUTModel","title":"LUTModel","text":"<p>               Bases: <code>NDVModel</code></p> <p>Representation of how to display a channel of an array.</p> <p>Attributes:</p> <ul> <li> <code>visible</code>               (<code>bool</code>)           \u2013            <p>Whether to display this channel. NOTE: This has implications for data retrieval, as we may not want to request channels that are not visible. See <code>ArrayDisplayModel.current_index</code>.</p> </li> <li> <code>cmap</code>               (<code>Colormap</code>)           \u2013            <p><code>cmap.Colormap</code> to use for this channel.  This can be expressed as any channel.  This can be expressed as any \"colormap like\" object</p> </li> <li> <code>clims</code>               (<code>Union[ClimsManual, ClimsPercentile, ClimsStdDev, ClimsMinMax]</code>)           \u2013            <p>Method for determining the contrast limits for this channel.  If a 2-element <code>tuple</code> or <code>list</code> is provided, it is interpreted as a manual contrast limit.</p> </li> <li> <code>gamma</code>               (<code>float</code>)           \u2013            <p>Gamma applied to the data before applying the colormap. By default, <code>1.0</code>.</p> </li> </ul>"},{"location":"reference/ndv/models/#ndv.models.NDVModel","title":"NDVModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base evented model for NDV models.</p> <p>Uses pydantic.BaseModel and psygnal.SignalGroupDescriptor.</p>"},{"location":"reference/ndv/models/#ndv.models.RectangularROIModel","title":"RectangularROIModel","text":"<p>               Bases: <code>NDVModel</code></p> <p>Representation of an axis-aligned rectangular Region of Interest (ROI).</p> <p>Attributes:</p> <ul> <li> <code>visible</code>               (<code>bool</code>)           \u2013            <p>Whether to display this roi.</p> </li> <li> <code>bounding_box</code>               (<code>tuple[tuple[float, float], tuple[float, float]]</code>)           \u2013            <p>The minimum (2D) point and the maximum (2D) point contained within the region. Using these two points, an axis-aligned bounding box can be constructed.</p> </li> </ul>"},{"location":"reference/ndv/util/","title":"ndv.util","text":""},{"location":"reference/ndv/util/#ndv.util","title":"ndv.util","text":"<p>Utility and convenience functions.</p> <p>Functions:</p> <ul> <li> <code>imshow</code>             \u2013              <p>Display an array or DataWrapper in a new <code>ArrayViewer</code> window.</p> </li> </ul>"},{"location":"reference/ndv/util/#ndv.util.imshow","title":"imshow","text":"<pre><code>imshow(\n    data: Any | DataWrapper,\n    /,\n    display_model: ArrayDisplayModel = ...,\n) -&gt; ArrayViewer\n</code></pre><pre><code>imshow(\n    data: Any | DataWrapper,\n    /,\n    **kwargs: Unpack[ArrayDisplayModelKwargs],\n) -&gt; ArrayViewer\n</code></pre> <pre><code>imshow(\n    data: Any | DataWrapper,\n    /,\n    display_model: ArrayDisplayModel | None = None,\n    **kwargs: Unpack[ArrayDisplayModelKwargs],\n) -&gt; ArrayViewer\n</code></pre> <p>Display an array or DataWrapper in a new <code>ArrayViewer</code> window.</p> <p>This convenience function creates an <code>ArrayViewer</code> instance populated with <code>data</code>, calls <code>show()</code> on it, and then runs the application.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ArrayViewer</code>           \u2013            <p>The <code>ArrayViewer</code> instance.</p> </li> </ul> Source code in <code>src/ndv/util.py</code> <pre><code>def imshow(\n    data: Any | DataWrapper,\n    /,\n    display_model: ArrayDisplayModel | None = None,\n    **kwargs: Unpack[ArrayDisplayModelKwargs],\n) -&gt; ArrayViewer:\n    \"\"\"Display an array or DataWrapper in a new `ArrayViewer` window.\n\n    This convenience function creates an `ArrayViewer` instance populated with `data`,\n    calls `show()` on it, and then runs the application.\n\n    Parameters\n    ----------\n    data : Any | DataWrapper\n        The data to be displayed. Any ArrayLike object or an `ndv.DataWrapper`.\n    display_model: ArrayDisplayModel, optional\n        The display model to use. If not provided, a new one will be created.\n    kwargs : Unpack[ArrayDisplayModelKwargs]\n        Additional keyword arguments used to create the\n        [`ArrayDisplayModel`][ndv.models.ArrayDisplayModel].\n\n    Returns\n    -------\n    ArrayViewer\n        The `ArrayViewer` instance.\n    \"\"\"\n    viewer = ArrayViewer(data, display_model, **kwargs)\n    viewer.show()\n\n    run_app()\n    return viewer\n</code></pre>"},{"location":"reference/ndv/util/#ndv.util.imshow(data)","title":"<code>data</code>","text":"(<code>Any | DataWrapper</code>)           \u2013            <p>The data to be displayed. Any ArrayLike object or an <code>ndv.DataWrapper</code>.</p>"},{"location":"reference/ndv/util/#ndv.util.imshow(display_model)","title":"<code>display_model</code>","text":"(<code>ArrayDisplayModel | None</code>, default:                   <code>None</code> )           \u2013            <p>The display model to use. If not provided, a new one will be created.</p>"},{"location":"reference/ndv/util/#ndv.util.imshow(kwargs)","title":"<code>kwargs</code>","text":"(<code>Unpack[ArrayDisplayModelKwargs]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments used to create the <code>ArrayDisplayModel</code>.</p>"},{"location":"reference/ndv/views/","title":"ndv.views","text":""},{"location":"reference/ndv/views/#ndv.views","title":"ndv.views","text":"<p>Wrappers around GUI &amp; graphics frameworks.</p> <p>Most stuff in this module is not intended for public use, but <code>ndv.views.bases</code> shows the protocol that GUI &amp; graphics classes should implement.</p> <p>Modules:</p> <ul> <li> <code>bases</code>           \u2013            <p>Abstract base classes for views and viewable objects.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>CanvasBackend</code>           \u2013            <p>Enum of available canvas backends.</p> </li> <li> <code>GuiFrontend</code>           \u2013            <p>Enum of available GUI frontends.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>call_later</code>             \u2013              <p>Call <code>func</code> after <code>msec</code> milliseconds.</p> </li> <li> <code>get_array_canvas_class</code>             \u2013              <p>Return <code>ArrayCanvas</code> class for current canvas backend.</p> </li> <li> <code>get_array_view_class</code>             \u2013              <p>Return <code>ArrayView</code> class for current GUI frontend.</p> </li> <li> <code>get_histogram_canvas_class</code>             \u2013              <p>Return <code>HistogramCanvas</code> class for current canvas backend.</p> </li> <li> <code>run_app</code>             \u2013              <p>Start the active GUI application event loop.</p> </li> </ul>"},{"location":"reference/ndv/views/#ndv.views.CanvasBackend","title":"CanvasBackend","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum of available canvas backends.</p> <p>Attributes:</p> <ul> <li> <code>VISPY</code>               (<code>str</code>)           \u2013            <p>Vispy</p> </li> <li> <code>PYGFX</code>               (<code>str</code>)           \u2013            <p>Pygfx</p> </li> </ul>"},{"location":"reference/ndv/views/#ndv.views.GuiFrontend","title":"GuiFrontend","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum of available GUI frontends.</p> <p>Attributes:</p> <ul> <li> <code>QT</code>               (<code>str</code>)           \u2013            <p>PyQt5/PySide2/PyQt6/PySide6</p> </li> <li> <code>JUPYTER</code>               (<code>str</code>)           \u2013            <p>Jupyter notebook/lab</p> </li> <li> <code>WX</code>               (<code>str</code>)           \u2013            <p>wxPython</p> </li> </ul>"},{"location":"reference/ndv/views/#ndv.views.call_later","title":"call_later","text":"<pre><code>call_later(msec: int, func: Callable[[], None]) -&gt; None\n</code></pre> <p>Call <code>func</code> after <code>msec</code> milliseconds.</p> <p>This can be used to enqueue a function to be called after the current event loop iteration.  For example, before calling <code>run_app()</code>, to ensure that the event loop is running before the function is called.</p> <p>Parameters:</p> Source code in <code>src/ndv/views/_app.py</code> <pre><code>def call_later(msec: int, func: Callable[[], None]) -&gt; None:\n    \"\"\"Call `func` after `msec` milliseconds.\n\n    This can be used to enqueue a function to be called after the current event loop\n    iteration.  For example, before calling `run_app()`, to ensure that the event\n    loop is running before the function is called.\n\n    Parameters\n    ----------\n    msec : int\n        The number of milliseconds to wait before calling `func`.\n    func : Callable[[], None]\n        The function to call.\n    \"\"\"\n    ndv_app().call_later(msec, func)\n</code></pre>"},{"location":"reference/ndv/views/#ndv.views.call_later(msec)","title":"<code>msec</code>","text":"(<code>int</code>)           \u2013            <p>The number of milliseconds to wait before calling <code>func</code>.</p>"},{"location":"reference/ndv/views/#ndv.views.call_later(func)","title":"<code>func</code>","text":"(<code>Callable[[], None]</code>)           \u2013            <p>The function to call.</p>"},{"location":"reference/ndv/views/#ndv.views.get_array_canvas_class","title":"get_array_canvas_class","text":"<pre><code>get_array_canvas_class(\n    backend: str | None = None,\n) -&gt; type[ArrayCanvas]\n</code></pre> <p>Return <code>ArrayCanvas</code> class for current canvas backend.</p> Source code in <code>src/ndv/views/_app.py</code> <pre><code>def get_array_canvas_class(backend: str | None = None) -&gt; type[ArrayCanvas]:\n    \"\"\"Return [`ArrayCanvas`][ndv.views.bases.ArrayCanvas] class for current canvas backend.\"\"\"  # noqa: E501\n    _backend = canvas_backend(backend)\n    if _backend not in CANVAS_PROVIDERS:  # pragma: no cover\n        raise NotImplementedError(f\"No canvas backend found for {_backend}\")\n    return CANVAS_PROVIDERS[_backend].array_canvas_class()\n</code></pre>"},{"location":"reference/ndv/views/#ndv.views.get_array_view_class","title":"get_array_view_class","text":"<pre><code>get_array_view_class() -&gt; type[ArrayView]\n</code></pre> <p>Return <code>ArrayView</code> class for current GUI frontend.</p> Source code in <code>src/ndv/views/_app.py</code> <pre><code>def get_array_view_class() -&gt; type[ArrayView]:\n    \"\"\"Return [`ArrayView`][ndv.views.bases.ArrayView] class for current GUI frontend.\"\"\"  # noqa: E501\n    return ndv_app().array_view_class()\n</code></pre>"},{"location":"reference/ndv/views/#ndv.views.get_histogram_canvas_class","title":"get_histogram_canvas_class","text":"<pre><code>get_histogram_canvas_class(\n    backend: str | None = None,\n) -&gt; type[HistogramCanvas]\n</code></pre> <p>Return <code>HistogramCanvas</code> class for current canvas backend.</p> Source code in <code>src/ndv/views/_app.py</code> <pre><code>def get_histogram_canvas_class(backend: str | None = None) -&gt; type[HistogramCanvas]:\n    \"\"\"Return [`HistogramCanvas`][ndv.views.bases.HistogramCanvas] class for current canvas backend.\"\"\"  # noqa: E501\n    _backend = canvas_backend(backend)\n    if _backend not in CANVAS_PROVIDERS:  # pragma: no cover\n        raise NotImplementedError(f\"No canvas backend found for {_backend}\")\n    return CANVAS_PROVIDERS[_backend].histogram_canvas_class()\n</code></pre>"},{"location":"reference/ndv/views/#ndv.views.run_app","title":"run_app","text":"<pre><code>run_app() -&gt; None\n</code></pre> <p>Start the active GUI application event loop.</p> Source code in <code>src/ndv/views/_app.py</code> <pre><code>def run_app() -&gt; None:\n    \"\"\"Start the active GUI application event loop.\"\"\"\n    ndv_app().run()\n</code></pre>"},{"location":"reference/ndv/views/bases/","title":"ndv.views.bases","text":""},{"location":"reference/ndv/views/bases/#ndv.views.bases","title":"ndv.views.bases","text":"<p>Abstract base classes for views and viewable objects.</p> <p>Classes:</p> <ul> <li> <code>ArrayCanvas</code>           \u2013            <p>ABC for canvases that show array data.</p> </li> <li> <code>ArrayView</code>           \u2013            <p>ABC for ND Array viewers widget.</p> </li> <li> <code>CanvasElement</code>           \u2013            <p>Protocol defining an interactive element on the Canvas.</p> </li> <li> <code>HistogramCanvas</code>           \u2013            <p>A histogram-based view for LookUp Table (LUT) adjustment.</p> </li> <li> <code>LutView</code>           \u2013            <p>Manages LUT properties (contrast, colormap, etc...) in a view object.</p> </li> <li> <code>Mouseable</code>           \u2013            <p>Mixin class for objects that can be interacted with using the mouse.</p> </li> <li> <code>NDVApp</code>           \u2013            <p>Base class for application wrappers.</p> </li> <li> <code>RectangularROIHandle</code>           \u2013            <p>An axis-aligned rectanglular ROI.</p> </li> <li> <code>Viewable</code>           \u2013            <p>ABC representing anything that can be viewed on screen.</p> </li> </ul>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.ArrayCanvas","title":"ArrayCanvas","text":"<pre><code>ArrayCanvas(viewer_model: ArrayViewerModel | None = ...)\n</code></pre> <p>               Bases: <code>GraphicsCanvas</code></p> <p>ABC for canvases that show array data.</p> <p>Methods:</p> <ul> <li> <code>canvas_to_world</code>             \u2013              <p>Map XY canvas position (pixels) to XYZ coordinate in world space.</p> </li> <li> <code>close</code>             \u2013              <p>Close the view/widget.</p> </li> <li> <code>frontend_widget</code>             \u2013              <p>Return the native object backing the viewable objects.</p> </li> <li> <code>set_visible</code>             \u2013              <p>Sets the visibility of the view/widget itself.</p> </li> </ul> Source code in <code>src/ndv/views/bases/_graphics/_canvas.py</code> <pre><code>@abstractmethod\ndef __init__(self, viewer_model: ArrayViewerModel | None = ...) -&gt; None: ...\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.ArrayCanvas.canvas_to_world","title":"canvas_to_world  <code>abstractmethod</code>","text":"<pre><code>canvas_to_world(\n    pos_xy: tuple[float, float],\n) -&gt; tuple[float, float, float]\n</code></pre> <p>Map XY canvas position (pixels) to XYZ coordinate in world space.</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas.py</code> <pre><code>@abstractmethod\ndef canvas_to_world(\n    self, pos_xy: tuple[float, float]\n) -&gt; tuple[float, float, float]:\n    \"\"\"Map XY canvas position (pixels) to XYZ coordinate in world space.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.ArrayCanvas.close","title":"close  <code>abstractmethod</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the view/widget.</p> Source code in <code>src/ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef close(self) -&gt; None:\n    \"\"\"Close the view/widget.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.ArrayCanvas.frontend_widget","title":"frontend_widget  <code>abstractmethod</code>","text":"<pre><code>frontend_widget() -&gt; Any\n</code></pre> <p>Return the native object backing the viewable objects.</p> Source code in <code>src/ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef frontend_widget(self) -&gt; Any:\n    \"\"\"Return the native object backing the viewable objects.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.ArrayCanvas.set_visible","title":"set_visible  <code>abstractmethod</code>","text":"<pre><code>set_visible(visible: bool) -&gt; None\n</code></pre> <p>Sets the visibility of the view/widget itself.</p> Source code in <code>src/ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef set_visible(self, visible: bool) -&gt; None:\n    \"\"\"Sets the visibility of the view/widget itself.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.ArrayView","title":"ArrayView","text":"<pre><code>ArrayView(\n    canvas_widget: Any,\n    model: _ArrayDataDisplayModel,\n    viewer_model: ArrayViewerModel,\n    **kwargs: Any,\n)\n</code></pre> <p>               Bases: <code>Viewable</code></p> <p>ABC for ND Array viewers widget.</p> <p>Currently, this is the \"main\" widget that contains the array display and all the controls for interacting with the array, including sliders, LUTs, and histograms.</p> <p>Methods:</p> <ul> <li> <code>close</code>             \u2013              <p>Close the view/widget.</p> </li> <li> <code>frontend_widget</code>             \u2013              <p>Return the native object backing the viewable objects.</p> </li> <li> <code>set_visible</code>             \u2013              <p>Sets the visibility of the view/widget itself.</p> </li> </ul> Source code in <code>src/ndv/views/bases/_array_view.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    canvas_widget: Any,\n    model: _ArrayDataDisplayModel,\n    viewer_model: ArrayViewerModel,\n    **kwargs: Any,\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.ArrayView.close","title":"close  <code>abstractmethod</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the view/widget.</p> Source code in <code>src/ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef close(self) -&gt; None:\n    \"\"\"Close the view/widget.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.ArrayView.frontend_widget","title":"frontend_widget  <code>abstractmethod</code>","text":"<pre><code>frontend_widget() -&gt; Any\n</code></pre> <p>Return the native object backing the viewable objects.</p> Source code in <code>src/ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef frontend_widget(self) -&gt; Any:\n    \"\"\"Return the native object backing the viewable objects.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.ArrayView.set_visible","title":"set_visible  <code>abstractmethod</code>","text":"<pre><code>set_visible(visible: bool) -&gt; None\n</code></pre> <p>Sets the visibility of the view/widget itself.</p> Source code in <code>src/ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef set_visible(self, visible: bool) -&gt; None:\n    \"\"\"Sets the visibility of the view/widget itself.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.CanvasElement","title":"CanvasElement","text":"<p>               Bases: <code>Mouseable</code></p> <p>Protocol defining an interactive element on the Canvas.</p> <p>Methods:</p> <ul> <li> <code>can_select</code>             \u2013              <p>Defines whether the element can be selected.</p> </li> <li> <code>remove</code>             \u2013              <p>Removes the element from the canvas.</p> </li> <li> <code>selected</code>             \u2013              <p>Returns element selection status.</p> </li> <li> <code>set_selected</code>             \u2013              <p>Sets element selection status.</p> </li> <li> <code>set_visible</code>             \u2013              <p>Sets element visibility.</p> </li> <li> <code>visible</code>             \u2013              <p>Defines whether the element is visible on the canvas.</p> </li> </ul>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.CanvasElement.can_select","title":"can_select  <code>abstractmethod</code>","text":"<pre><code>can_select() -&gt; bool\n</code></pre> <p>Defines whether the element can be selected.</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>@abstractmethod\ndef can_select(self) -&gt; bool:\n    \"\"\"Defines whether the element can be selected.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.CanvasElement.remove","title":"remove","text":"<pre><code>remove() -&gt; None\n</code></pre> <p>Removes the element from the canvas.</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>def remove(self) -&gt; None:\n    \"\"\"Removes the element from the canvas.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.CanvasElement.selected","title":"selected  <code>abstractmethod</code>","text":"<pre><code>selected() -&gt; bool\n</code></pre> <p>Returns element selection status.</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>@abstractmethod\ndef selected(self) -&gt; bool:\n    \"\"\"Returns element selection status.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.CanvasElement.set_selected","title":"set_selected  <code>abstractmethod</code>","text":"<pre><code>set_selected(selected: bool) -&gt; None\n</code></pre> <p>Sets element selection status.</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>@abstractmethod\ndef set_selected(self, selected: bool) -&gt; None:\n    \"\"\"Sets element selection status.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.CanvasElement.set_visible","title":"set_visible  <code>abstractmethod</code>","text":"<pre><code>set_visible(visible: bool) -&gt; None\n</code></pre> <p>Sets element visibility.</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>@abstractmethod\ndef set_visible(self, visible: bool) -&gt; None:\n    \"\"\"Sets element visibility.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.CanvasElement.visible","title":"visible  <code>abstractmethod</code>","text":"<pre><code>visible() -&gt; bool\n</code></pre> <p>Defines whether the element is visible on the canvas.</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>@abstractmethod\ndef visible(self) -&gt; bool:\n    \"\"\"Defines whether the element is visible on the canvas.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas","title":"HistogramCanvas","text":"<p>               Bases: <code>GraphicsCanvas</code>, <code>LutView</code></p> <p>A histogram-based view for LookUp Table (LUT) adjustment.</p> <p>Methods:</p> <ul> <li> <code>canvas_to_world</code>             \u2013              <p>Map XY canvas position (pixels) to XYZ coordinate in world space.</p> </li> <li> <code>close</code>             \u2013              <p>Close the view/widget.</p> </li> <li> <code>frontend_widget</code>             \u2013              <p>Return the native object backing the viewable objects.</p> </li> <li> <code>set_channel_name</code>             \u2013              <p>Set the name of the channel to <code>name</code>.</p> </li> <li> <code>set_channel_visible</code>             \u2013              <p>Check or uncheck the visibility indicator of the LUT.</p> </li> <li> <code>set_clim_policy</code>             \u2013              <p>Set the clim policy to <code>policy</code>.</p> </li> <li> <code>set_clims</code>             \u2013              <p>Set the (low, high) contrast limits to <code>clims</code>.</p> </li> <li> <code>set_colormap</code>             \u2013              <p>Set the colormap to <code>cmap</code>.</p> </li> <li> <code>set_data</code>             \u2013              <p>Sets the histogram data.</p> </li> <li> <code>set_gamma</code>             \u2013              <p>Set the gamma value of the LUT.</p> </li> <li> <code>set_log_base</code>             \u2013              <p>Sets the axis scale of the range.</p> </li> <li> <code>set_vertical</code>             \u2013              <p>If True, orient axes vertically (x-axis on left).</p> </li> <li> <code>set_visible</code>             \u2013              <p>Sets the visibility of the view/widget itself.</p> </li> <li> <code>synchronize</code>             \u2013              <p>Aligns the view against the backing model.</p> </li> </ul>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.canvas_to_world","title":"canvas_to_world  <code>abstractmethod</code>","text":"<pre><code>canvas_to_world(\n    pos_xy: tuple[float, float],\n) -&gt; tuple[float, float, float]\n</code></pre> <p>Map XY canvas position (pixels) to XYZ coordinate in world space.</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas.py</code> <pre><code>@abstractmethod\ndef canvas_to_world(\n    self, pos_xy: tuple[float, float]\n) -&gt; tuple[float, float, float]:\n    \"\"\"Map XY canvas position (pixels) to XYZ coordinate in world space.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.close","title":"close  <code>abstractmethod</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the view/widget.</p> Source code in <code>src/ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef close(self) -&gt; None:\n    \"\"\"Close the view/widget.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.frontend_widget","title":"frontend_widget  <code>abstractmethod</code>","text":"<pre><code>frontend_widget() -&gt; Any\n</code></pre> <p>Return the native object backing the viewable objects.</p> Source code in <code>src/ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef frontend_widget(self) -&gt; Any:\n    \"\"\"Return the native object backing the viewable objects.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.set_channel_name","title":"set_channel_name  <code>abstractmethod</code>","text":"<pre><code>set_channel_name(name: str) -&gt; None\n</code></pre> <p>Set the name of the channel to <code>name</code>.</p> Source code in <code>src/ndv/views/bases/_lut_view.py</code> <pre><code>@abstractmethod\ndef set_channel_name(self, name: str) -&gt; None:\n    \"\"\"Set the name of the channel to `name`.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.set_channel_visible","title":"set_channel_visible  <code>abstractmethod</code>","text":"<pre><code>set_channel_visible(visible: bool) -&gt; None\n</code></pre> <p>Check or uncheck the visibility indicator of the LUT.</p> <p>Usually corresponds to a checkbox.</p> <p>Note that this method must not modify the backing LUTModel.</p> Source code in <code>src/ndv/views/bases/_lut_view.py</code> <pre><code>@abstractmethod\ndef set_channel_visible(self, visible: bool) -&gt; None:\n    \"\"\"Check or uncheck the visibility indicator of the LUT.\n\n    Usually corresponds to a checkbox.\n\n    Note that this method must not modify the backing LUTModel.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.set_clim_policy","title":"set_clim_policy  <code>abstractmethod</code>","text":"<pre><code>set_clim_policy(policy: ClimPolicy) -&gt; None\n</code></pre> <p>Set the clim policy to <code>policy</code>.</p> <p>Usually corresponds to an \"autoscale\" checkbox.</p> <p>Note that this method must not modify the backing LUTModel.</p> Source code in <code>src/ndv/views/bases/_lut_view.py</code> <pre><code>@abstractmethod\ndef set_clim_policy(self, policy: ClimPolicy) -&gt; None:\n    \"\"\"Set the clim policy to `policy`.\n\n    Usually corresponds to an \"autoscale\" checkbox.\n\n    Note that this method must not modify the backing LUTModel.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.set_clims","title":"set_clims  <code>abstractmethod</code>","text":"<pre><code>set_clims(clims: tuple[float, float]) -&gt; None\n</code></pre> <p>Set the (low, high) contrast limits to <code>clims</code>.</p> <p>Usually this will be a range slider or two text boxes.</p> <p>Note that this method must not modify the backing LUTModel.</p> Source code in <code>src/ndv/views/bases/_lut_view.py</code> <pre><code>@abstractmethod\ndef set_clims(self, clims: tuple[float, float]) -&gt; None:\n    \"\"\"Set the (low, high) contrast limits to `clims`.\n\n    Usually this will be a range slider or two text boxes.\n\n    Note that this method must not modify the backing LUTModel.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.set_colormap","title":"set_colormap  <code>abstractmethod</code>","text":"<pre><code>set_colormap(cmap: Colormap) -&gt; None\n</code></pre> <p>Set the colormap to <code>cmap</code>.</p> <p>Usually corresponds to a dropdown menu.</p> <p>Note that this method must not modify the backing LUTModel.</p> Source code in <code>src/ndv/views/bases/_lut_view.py</code> <pre><code>@abstractmethod\ndef set_colormap(self, cmap: cmap.Colormap) -&gt; None:\n    \"\"\"Set the colormap to `cmap`.\n\n    Usually corresponds to a dropdown menu.\n\n    Note that this method must not modify the backing LUTModel.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.set_data","title":"set_data","text":"<pre><code>set_data(values: ndarray, bin_edges: ndarray) -&gt; None\n</code></pre> <p>Sets the histogram data.</p> Properties <p>values : np.ndarray     The histogram values. bin_edges : np.ndarray     The bin edges of the histogram.</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas.py</code> <pre><code>def set_data(self, values: np.ndarray, bin_edges: np.ndarray) -&gt; None:\n    \"\"\"Sets the histogram data.\n\n    Properties\n    ----------\n    values : np.ndarray\n        The histogram values.\n    bin_edges : np.ndarray\n        The bin edges of the histogram.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.set_gamma","title":"set_gamma","text":"<pre><code>set_gamma(gamma: float) -&gt; None\n</code></pre> <p>Set the gamma value of the LUT.</p> <p>Note that this method must not modify the backing LUTModel.</p> Source code in <code>src/ndv/views/bases/_lut_view.py</code> <pre><code>def set_gamma(self, gamma: float) -&gt; None:\n    \"\"\"Set the gamma value of the LUT.\n\n    Note that this method must not modify the backing LUTModel.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.set_log_base","title":"set_log_base","text":"<pre><code>set_log_base(base: float | None) -&gt; None\n</code></pre> <p>Sets the axis scale of the range.</p> Properties <p>enabled : bool     If true, the range will be displayed with a logarithmic (base 10)     scale. If false, the range will be displayed with a linear scale.</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas.py</code> <pre><code>def set_log_base(self, base: float | None) -&gt; None:\n    \"\"\"Sets the axis scale of the range.\n\n    Properties\n    ----------\n    enabled : bool\n        If true, the range will be displayed with a logarithmic (base 10)\n        scale. If false, the range will be displayed with a linear scale.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.set_vertical","title":"set_vertical","text":"<pre><code>set_vertical(vertical: bool) -&gt; None\n</code></pre> <p>If True, orient axes vertically (x-axis on left).</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas.py</code> <pre><code>def set_vertical(self, vertical: bool) -&gt; None:\n    \"\"\"If True, orient axes vertically (x-axis on left).\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.set_visible","title":"set_visible  <code>abstractmethod</code>","text":"<pre><code>set_visible(visible: bool) -&gt; None\n</code></pre> <p>Sets the visibility of the view/widget itself.</p> Source code in <code>src/ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef set_visible(self, visible: bool) -&gt; None:\n    \"\"\"Sets the visibility of the view/widget itself.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.synchronize","title":"synchronize","text":"<pre><code>synchronize() -&gt; None\n</code></pre> <p>Aligns the view against the backing model.</p> Source code in <code>src/ndv/views/bases/_lut_view.py</code> <pre><code>def synchronize(self) -&gt; None:\n    \"\"\"Aligns the view against the backing model.\"\"\"\n    if model := self._model:\n        self.set_clim_policy(model.clims)\n        self.set_colormap(model.cmap)\n        self.set_gamma(model.gamma)\n        self.set_channel_visible(model.visible)\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView","title":"LutView","text":"<p>               Bases: <code>Viewable</code></p> <p>Manages LUT properties (contrast, colormap, etc...) in a view object.</p> <p>Methods:</p> <ul> <li> <code>close</code>             \u2013              <p>Close the view/widget.</p> </li> <li> <code>frontend_widget</code>             \u2013              <p>Return the native object backing the viewable objects.</p> </li> <li> <code>set_channel_name</code>             \u2013              <p>Set the name of the channel to <code>name</code>.</p> </li> <li> <code>set_channel_visible</code>             \u2013              <p>Check or uncheck the visibility indicator of the LUT.</p> </li> <li> <code>set_clim_policy</code>             \u2013              <p>Set the clim policy to <code>policy</code>.</p> </li> <li> <code>set_clims</code>             \u2013              <p>Set the (low, high) contrast limits to <code>clims</code>.</p> </li> <li> <code>set_colormap</code>             \u2013              <p>Set the colormap to <code>cmap</code>.</p> </li> <li> <code>set_gamma</code>             \u2013              <p>Set the gamma value of the LUT.</p> </li> <li> <code>set_visible</code>             \u2013              <p>Sets the visibility of the view/widget itself.</p> </li> <li> <code>synchronize</code>             \u2013              <p>Aligns the view against the backing model.</p> </li> </ul>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView.close","title":"close  <code>abstractmethod</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the view/widget.</p> Source code in <code>src/ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef close(self) -&gt; None:\n    \"\"\"Close the view/widget.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView.frontend_widget","title":"frontend_widget  <code>abstractmethod</code>","text":"<pre><code>frontend_widget() -&gt; Any\n</code></pre> <p>Return the native object backing the viewable objects.</p> Source code in <code>src/ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef frontend_widget(self) -&gt; Any:\n    \"\"\"Return the native object backing the viewable objects.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView.set_channel_name","title":"set_channel_name  <code>abstractmethod</code>","text":"<pre><code>set_channel_name(name: str) -&gt; None\n</code></pre> <p>Set the name of the channel to <code>name</code>.</p> Source code in <code>src/ndv/views/bases/_lut_view.py</code> <pre><code>@abstractmethod\ndef set_channel_name(self, name: str) -&gt; None:\n    \"\"\"Set the name of the channel to `name`.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView.set_channel_visible","title":"set_channel_visible  <code>abstractmethod</code>","text":"<pre><code>set_channel_visible(visible: bool) -&gt; None\n</code></pre> <p>Check or uncheck the visibility indicator of the LUT.</p> <p>Usually corresponds to a checkbox.</p> <p>Note that this method must not modify the backing LUTModel.</p> Source code in <code>src/ndv/views/bases/_lut_view.py</code> <pre><code>@abstractmethod\ndef set_channel_visible(self, visible: bool) -&gt; None:\n    \"\"\"Check or uncheck the visibility indicator of the LUT.\n\n    Usually corresponds to a checkbox.\n\n    Note that this method must not modify the backing LUTModel.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView.set_clim_policy","title":"set_clim_policy  <code>abstractmethod</code>","text":"<pre><code>set_clim_policy(policy: ClimPolicy) -&gt; None\n</code></pre> <p>Set the clim policy to <code>policy</code>.</p> <p>Usually corresponds to an \"autoscale\" checkbox.</p> <p>Note that this method must not modify the backing LUTModel.</p> Source code in <code>src/ndv/views/bases/_lut_view.py</code> <pre><code>@abstractmethod\ndef set_clim_policy(self, policy: ClimPolicy) -&gt; None:\n    \"\"\"Set the clim policy to `policy`.\n\n    Usually corresponds to an \"autoscale\" checkbox.\n\n    Note that this method must not modify the backing LUTModel.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView.set_clims","title":"set_clims  <code>abstractmethod</code>","text":"<pre><code>set_clims(clims: tuple[float, float]) -&gt; None\n</code></pre> <p>Set the (low, high) contrast limits to <code>clims</code>.</p> <p>Usually this will be a range slider or two text boxes.</p> <p>Note that this method must not modify the backing LUTModel.</p> Source code in <code>src/ndv/views/bases/_lut_view.py</code> <pre><code>@abstractmethod\ndef set_clims(self, clims: tuple[float, float]) -&gt; None:\n    \"\"\"Set the (low, high) contrast limits to `clims`.\n\n    Usually this will be a range slider or two text boxes.\n\n    Note that this method must not modify the backing LUTModel.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView.set_colormap","title":"set_colormap  <code>abstractmethod</code>","text":"<pre><code>set_colormap(cmap: Colormap) -&gt; None\n</code></pre> <p>Set the colormap to <code>cmap</code>.</p> <p>Usually corresponds to a dropdown menu.</p> <p>Note that this method must not modify the backing LUTModel.</p> Source code in <code>src/ndv/views/bases/_lut_view.py</code> <pre><code>@abstractmethod\ndef set_colormap(self, cmap: cmap.Colormap) -&gt; None:\n    \"\"\"Set the colormap to `cmap`.\n\n    Usually corresponds to a dropdown menu.\n\n    Note that this method must not modify the backing LUTModel.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView.set_gamma","title":"set_gamma","text":"<pre><code>set_gamma(gamma: float) -&gt; None\n</code></pre> <p>Set the gamma value of the LUT.</p> <p>Note that this method must not modify the backing LUTModel.</p> Source code in <code>src/ndv/views/bases/_lut_view.py</code> <pre><code>def set_gamma(self, gamma: float) -&gt; None:\n    \"\"\"Set the gamma value of the LUT.\n\n    Note that this method must not modify the backing LUTModel.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView.set_visible","title":"set_visible  <code>abstractmethod</code>","text":"<pre><code>set_visible(visible: bool) -&gt; None\n</code></pre> <p>Sets the visibility of the view/widget itself.</p> Source code in <code>src/ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef set_visible(self, visible: bool) -&gt; None:\n    \"\"\"Sets the visibility of the view/widget itself.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView.synchronize","title":"synchronize","text":"<pre><code>synchronize() -&gt; None\n</code></pre> <p>Aligns the view against the backing model.</p> Source code in <code>src/ndv/views/bases/_lut_view.py</code> <pre><code>def synchronize(self) -&gt; None:\n    \"\"\"Aligns the view against the backing model.\"\"\"\n    if model := self._model:\n        self.set_clim_policy(model.clims)\n        self.set_colormap(model.cmap)\n        self.set_gamma(model.gamma)\n        self.set_channel_visible(model.visible)\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.Mouseable","title":"Mouseable","text":"<p>Mixin class for objects that can be interacted with using the mouse.</p> <p>The signals here are to be emitted by the view object that inherits this class; usually by intercepting native mouse events with <code>filter_mouse_events</code>.</p> <p>The methods allow the object to handle its own mouse events before emitting the signals. If the method returns <code>True</code>, the event is considered handled and should not be passed to the next receiver in the chain.</p>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.NDVApp","title":"NDVApp","text":"<p>Base class for application wrappers.</p> <p>Methods:</p> <ul> <li> <code>call_in_main_thread</code>             \u2013              <p>Call <code>func</code> in the main gui thread.</p> </li> <li> <code>call_later</code>             \u2013              <p>Call <code>func</code> after <code>msec</code> milliseconds.</p> </li> <li> <code>create_app</code>             \u2013              <p>Create the application instance, if not already created.</p> </li> <li> <code>filter_mouse_events</code>             \u2013              <p>Install mouse event filter on <code>canvas</code>, redirecting events to <code>receiver</code>.</p> </li> <li> <code>get_executor</code>             \u2013              <p>Return an executor for running tasks in the background.</p> </li> <li> <code>process_events</code>             \u2013              <p>Process events for the application.</p> </li> <li> <code>run</code>             \u2013              <p>Run the application.</p> </li> </ul>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.NDVApp.call_in_main_thread","title":"call_in_main_thread","text":"<pre><code>call_in_main_thread(\n    func: Callable[P, T], *args: args, **kwargs: kwargs\n) -&gt; Future[T]\n</code></pre> <p>Call <code>func</code> in the main gui thread.</p> Source code in <code>src/ndv/views/bases/_app.py</code> <pre><code>def call_in_main_thread(\n    self, func: Callable[P, T], *args: P.args, **kwargs: P.kwargs\n) -&gt; Future[T]:\n    \"\"\"Call `func` in the main gui thread.\"\"\"\n    future: Future[T] = Future()\n    future.set_result(func(*args, **kwargs))\n    return future\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.NDVApp.call_later","title":"call_later","text":"<pre><code>call_later(msec: int, func: Callable[[], None]) -&gt; None\n</code></pre> <p>Call <code>func</code> after <code>msec</code> milliseconds.</p> Source code in <code>src/ndv/views/bases/_app.py</code> <pre><code>def call_later(self, msec: int, func: Callable[[], None]) -&gt; None:\n    \"\"\"Call `func` after `msec` milliseconds.\"\"\"\n    # generic implementation using python threading\n\n    from threading import Timer\n\n    Timer(msec / 1000, func).start()\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.NDVApp.create_app","title":"create_app","text":"<pre><code>create_app() -&gt; Any\n</code></pre> <p>Create the application instance, if not already created.</p> Source code in <code>src/ndv/views/bases/_app.py</code> <pre><code>def create_app(self) -&gt; Any:\n    \"\"\"Create the application instance, if not already created.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.NDVApp.filter_mouse_events","title":"filter_mouse_events","text":"<pre><code>filter_mouse_events(\n    canvas: Any, receiver: Mouseable\n) -&gt; Callable[[], None]\n</code></pre> <p>Install mouse event filter on <code>canvas</code>, redirecting events to <code>receiver</code>.</p> Source code in <code>src/ndv/views/bases/_app.py</code> <pre><code>def filter_mouse_events(\n    self, canvas: Any, receiver: Mouseable\n) -&gt; Callable[[], None]:\n    \"\"\"Install mouse event filter on `canvas`, redirecting events to `receiver`.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.NDVApp.get_executor","title":"get_executor","text":"<pre><code>get_executor() -&gt; Executor\n</code></pre> <p>Return an executor for running tasks in the background.</p> Source code in <code>src/ndv/views/bases/_app.py</code> <pre><code>def get_executor(self) -&gt; Executor:\n    \"\"\"Return an executor for running tasks in the background.\"\"\"\n    return _thread_pool_executor()\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.NDVApp.process_events","title":"process_events","text":"<pre><code>process_events() -&gt; None\n</code></pre> <p>Process events for the application.</p> Source code in <code>src/ndv/views/bases/_app.py</code> <pre><code>def process_events(self) -&gt; None:\n    \"\"\"Process events for the application.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.NDVApp.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Run the application.</p> Source code in <code>src/ndv/views/bases/_app.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Run the application.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.RectangularROIHandle","title":"RectangularROIHandle","text":"<p>               Bases: <code>CanvasElement</code></p> <p>An axis-aligned rectanglular ROI.</p> <p>Methods:</p> <ul> <li> <code>can_select</code>             \u2013              <p>Defines whether the element can be selected.</p> </li> <li> <code>remove</code>             \u2013              <p>Removes the element from the canvas.</p> </li> <li> <code>selected</code>             \u2013              <p>Returns element selection status.</p> </li> <li> <code>set_border</code>             \u2013              <p>Sets the border color.</p> </li> <li> <code>set_bounding_box</code>             \u2013              <p>Sets the bounding box.</p> </li> <li> <code>set_fill</code>             \u2013              <p>Sets the fill color.</p> </li> <li> <code>set_handles</code>             \u2013              <p>Sets the handle face color.</p> </li> <li> <code>set_selected</code>             \u2013              <p>Sets element selection status.</p> </li> <li> <code>set_visible</code>             \u2013              <p>Sets element visibility.</p> </li> <li> <code>visible</code>             \u2013              <p>Defines whether the element is visible on the canvas.</p> </li> </ul>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.RectangularROIHandle.can_select","title":"can_select  <code>abstractmethod</code>","text":"<pre><code>can_select() -&gt; bool\n</code></pre> <p>Defines whether the element can be selected.</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>@abstractmethod\ndef can_select(self) -&gt; bool:\n    \"\"\"Defines whether the element can be selected.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.RectangularROIHandle.remove","title":"remove","text":"<pre><code>remove() -&gt; None\n</code></pre> <p>Removes the element from the canvas.</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>def remove(self) -&gt; None:\n    \"\"\"Removes the element from the canvas.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.RectangularROIHandle.selected","title":"selected  <code>abstractmethod</code>","text":"<pre><code>selected() -&gt; bool\n</code></pre> <p>Returns element selection status.</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>@abstractmethod\ndef selected(self) -&gt; bool:\n    \"\"\"Returns element selection status.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.RectangularROIHandle.set_border","title":"set_border","text":"<pre><code>set_border(color: Color) -&gt; None\n</code></pre> <p>Sets the border color.</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>def set_border(self, color: _cmap.Color) -&gt; None:\n    \"\"\"Sets the border color.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.RectangularROIHandle.set_bounding_box","title":"set_bounding_box","text":"<pre><code>set_bounding_box(\n    minimum: tuple[float, float],\n    maximum: tuple[float, float],\n) -&gt; None\n</code></pre> <p>Sets the bounding box.</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>def set_bounding_box(\n    self, minimum: tuple[float, float], maximum: tuple[float, float]\n) -&gt; None:\n    \"\"\"Sets the bounding box.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.RectangularROIHandle.set_fill","title":"set_fill","text":"<pre><code>set_fill(color: Color) -&gt; None\n</code></pre> <p>Sets the fill color.</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>def set_fill(self, color: _cmap.Color) -&gt; None:\n    \"\"\"Sets the fill color.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.RectangularROIHandle.set_handles","title":"set_handles","text":"<pre><code>set_handles(color: Color) -&gt; None\n</code></pre> <p>Sets the handle face color.</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>def set_handles(self, color: _cmap.Color) -&gt; None:\n    \"\"\"Sets the handle face color.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.RectangularROIHandle.set_selected","title":"set_selected  <code>abstractmethod</code>","text":"<pre><code>set_selected(selected: bool) -&gt; None\n</code></pre> <p>Sets element selection status.</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>@abstractmethod\ndef set_selected(self, selected: bool) -&gt; None:\n    \"\"\"Sets element selection status.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.RectangularROIHandle.set_visible","title":"set_visible  <code>abstractmethod</code>","text":"<pre><code>set_visible(visible: bool) -&gt; None\n</code></pre> <p>Sets element visibility.</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>@abstractmethod\ndef set_visible(self, visible: bool) -&gt; None:\n    \"\"\"Sets element visibility.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.RectangularROIHandle.visible","title":"visible  <code>abstractmethod</code>","text":"<pre><code>visible() -&gt; bool\n</code></pre> <p>Defines whether the element is visible on the canvas.</p> Source code in <code>src/ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>@abstractmethod\ndef visible(self) -&gt; bool:\n    \"\"\"Defines whether the element is visible on the canvas.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.Viewable","title":"Viewable","text":"<p>               Bases: <code>ABC</code></p> <p>ABC representing anything that can be viewed on screen.</p> <p>For example, a widget, a window, a frame, canvas, etc.</p> <p>Methods:</p> <ul> <li> <code>close</code>             \u2013              <p>Close the view/widget.</p> </li> <li> <code>frontend_widget</code>             \u2013              <p>Return the native object backing the viewable objects.</p> </li> <li> <code>set_visible</code>             \u2013              <p>Sets the visibility of the view/widget itself.</p> </li> </ul>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.Viewable.close","title":"close  <code>abstractmethod</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the view/widget.</p> Source code in <code>src/ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef close(self) -&gt; None:\n    \"\"\"Close the view/widget.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.Viewable.frontend_widget","title":"frontend_widget  <code>abstractmethod</code>","text":"<pre><code>frontend_widget() -&gt; Any\n</code></pre> <p>Return the native object backing the viewable objects.</p> Source code in <code>src/ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef frontend_widget(self) -&gt; Any:\n    \"\"\"Return the native object backing the viewable objects.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.Viewable.set_visible","title":"set_visible  <code>abstractmethod</code>","text":"<pre><code>set_visible(visible: bool) -&gt; None\n</code></pre> <p>Sets the visibility of the view/widget itself.</p> Source code in <code>src/ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef set_visible(self, visible: bool) -&gt; None:\n    \"\"\"Sets the visibility of the view/widget itself.\"\"\"\n</code></pre>"}]}