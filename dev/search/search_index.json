{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ndv","text":"<p>Simple, fast-loading, asynchronous, n-dimensional array viewer, with minimal dependencies.</p> <pre><code>import ndv\n\ndata = ndv.data.cells3d()  # or any arraylike object\nndv.imshow(data)\n</code></pre> <p></p> <p><code>ndv.imshow()</code> creates an instance of <code>ndv.ArrayViewer</code>, which you can also use directly:</p> <pre><code>import ndv\n\nviewer = ndv.ArrayViewer(data)\nviewer.show()\nndv.run_app()\n</code></pre> <p>Tip</p> <p>To embed the viewer in a broader Qt or wxPython application, you can access the viewer's <code>widget</code> attribute and add it to your layout.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\u26a1\ufe0f fast to import, fast to show</li> <li>\ud83e\udeb6 minimal dependencies</li> <li>\ud83d\udce6 supports arbitrary number of dimensions</li> <li>\ud83e\udd49 2D/3D view canvas</li> <li>\ud83c\udf20 supports VisPy or   pygfx backends</li> <li>\ud83d\udee0\ufe0f support Qt, wx, or   Jupyter GUI frontends</li> <li>\ud83c\udfa8 colormaps provided by cmap</li> <li>\ud83c\udff7\ufe0f supports named dimensions and categorical coordinate values (WIP)</li> <li>\ud83e\udd86 supports most array types, including:<ul> <li><code>numpy.ndarray</code></li> <li><code>cupy.ndarray</code></li> <li><code>dask.array.Array</code></li> <li><code>jax.Array</code></li> <li><code>pyopencl.array.Array</code></li> <li><code>sparse.COO</code></li> <li><code>tensorstore.TensorStore</code> (supports named dimensions)</li> <li><code>torch.Tensor</code> (supports named dimensions)</li> <li><code>xarray.DataArray</code> (supports named dimensions)</li> <li><code>zarr</code> (supports named dimensions)</li> </ul> </li> </ul> <p>See examples for each of these array types in examples</p> <p>Note</p> <p>You can add support for any custom storage class by subclassing <code>ndv.DataWrapper</code> and implementing a couple methods. (This doesn't require modifying ndv, but contributions of new wrappers are welcome!)</p>"},{"location":"#installation","title":"Installation","text":"<p>Because ndv supports many combinations of GUI and graphics frameworks, you must install it along with additional dependencies for your desired backend.</p> <p>See the installation guide for complete details.</p> <p>To just get started quickly using Qt and vispy:</p> <pre><code>pip install ndv[qt]\n</code></pre> <p>For Jupyter support, with no Qt requirement:</p> <pre><code>pip install ndv[jupyter]\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>For more information, and complete API reference, see the documentation.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>This package arose from the need for a way to quickly view multi-dimensional arrays with zero tolerance for long import times and/or excessive dependency lists. I want something that I can use to view any of the many multi-dimensional array types, out of the box, with no assumptions about dimensionality. I want it to work reasonably well with remote, asynchronously loaded data. I also want it to take advantage of things like named dimensions and categorical coordinate values when available. For now, it's a Qt-only widget, since that's where the need arose, but I can imagine a jupyter widget in the future (likely as a remote frame buffer for vispy/pygfx).</p> <p>I do not intend for this to grow into full-fledged application, or wrap a complete scene graph, though point and ROI selection would be welcome additions.</p>"},{"location":"install/","title":"Installation","text":"<p><code>ndv</code> can be used in a variety of contexts. It supports various GUI  frameworks, including PyQt,  PySide, wxPython,  and Jupyter Lab &amp; Notebooks.  It also works with  different graphics libraries, including VisPy (for  OpenGL) and Pygfx (for WebGPU).</p> <p>These frameworks are not included directly with <code>ndv</code> and must be installed independently. We provide a set of installation extras depending on the graphics and GUI libraries you want to use:</p>"},{"location":"install/#framework-selection","title":"Framework selection","text":"<p>If you have multiple GUI or graphics libraries installed, you can control which ones <code>ndv</code> uses with environment variables. The following variables are supported:</p> <ul> <li><code>NDV_CANVAS_BACKEND</code>: Set to <code>\"vispy\"</code> or <code>\"pygfx\"</code> to choose the graphics library.</li> <li><code>NDV_GUI_FRONTEND</code>: Set to <code>\"qt\"</code>, <code>\"wx\"</code>, or <code>\"jupyter\"</code> to choose the GUI library.</li> </ul> <p>Defaults</p> <p>GUI:</p> <p><code>ndv</code> tries to be aware of the GUI library you are using. So it will use <code>jupyter</code> if you are in a Jupyter notebook, <code>qt</code> if a <code>QApplication</code> is already running, and <code>wx</code> if a <code>wx.App</code> is already running. Finally, it will check available libraries in the order of <code>qt</code>, <code>wx</code>, <code>jupyter</code>.</p> <p>Graphics:</p> <p>If you have both VisPy and pygfx installed, <code>ndv</code> will (currently) default to using vispy.</p>"},{"location":"motivation/","title":"Motivation and Scope","text":"<p>It can be informative to know what problems the developers were trying to solve when creating a library, and under what constraints. <code>ndv</code> was created by a former napari core developer and collaborators out of a desire to quickly view multi-dimensional arrays with minimal import times minimal dependencies. The original need was for a component in a broader (microscope control) application, where a fast and minimal viewer was needed to display data.</p>"},{"location":"motivation/#goals","title":"Goals","text":"<ul> <li> N-dimensional viewer: The current focus is on viewing multi-dimensional     arrays (and currently just a single array at a time), with sliders     controlling slicing from an arbitrary number of dimensions. 2D and 3D     volumetric views are supported.</li> <li> Minimal dependencies: <code>ndv</code> should have as few dependencies  as     possible (both direct and indirect). Installing <code>napari[all]==0.5.5</code> into a     clean environment brings a total of 126 dependencies. <code>ndv[qt]==0.2.0</code> has     29, and we aim to keep that low.</li> <li> Quick to import: <code>ndv</code> should import and show a viewer in a reasonable     amount of time. \"Reasonable\" is of course relative and subjective, but we     aim for less than 1 second on a modern laptop (currently at &lt;100ms).</li> <li> Broad GUI Compatibility: A common feature request for <code>napari</code> is to support     Jupyter notebooks. <code>ndv</code> can work with Qt,     wxPython, and Jupyter.</li> <li> Flexible Graphics Providers: <code>ndv</code> works with VisPy in a classical OpenGL     context, but has an abstracting layer that allows for other graphics engines.     We currently also support <code>pygfx</code>, a WGPU-based graphics engine.</li> <li> Model/View architecture: <code>ndv</code> should have a clear separation between the     data model and the view. The model should be serializable and easily     transferable between different views.</li> <li> Asynchronous first: <code>ndv</code> should be asynchronous by default: meaning     that the data request/response process happens in the background, and the     GUI remains responsive. (Optimization of remote, multi-resolution data is on     the roadmap, but not currently implemented).</li> </ul>"},{"location":"motivation/#scope-and-roadmap","title":"Scope and Roadmap","text":"<p>We do want to support the following features:</p> <ul> <li> Multiple data sources: We want to allow for multiple data sources to be     displayed in the same viewer, with flexible coordinate transforms.</li> <li> Non-image data: We would like to support non-image data, such as points     segmentation masks, and meshes.</li> <li> Multi-resolution (pyramid) data: We would like to support multi-resolution     data, to allow for fast rendering of large datasets based on the current view.</li> <li> Frustum culling: We would like to support frustum culling to allow for     efficient rendering of large datasets.</li> <li> Ortho-viewer: <code>ndv</code>'s good model/view separation should allow for     easy creation of an orth viewer (e.g. synchronized <code>XY</code>, <code>XZ</code>, <code>YZ</code> views).</li> </ul>"},{"location":"motivation/#non-goals","title":"Non-Goals","text":"<p>We do not plan to support the following features in the near future (if ever):</p> <ul> <li>Image Processing: General image processing is out of scope. We aim to     provide a viewer, not a full image processing library.</li> <li>Interactive segmentation and painting: While extensible mouse event handling     is in scope, we don't intend to implement painting or  interactive     segmentation tools.</li> <li>Plugins: We don't intend to support a plugin architecture. We aim to keep     the core library as small as possible, and encourage users to build on top     of it with their own tools.</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> ndv<ul> <li> controllers</li> <li> data</li> <li> models</li> <li> util</li> <li> v1</li> <li> views<ul> <li> bases</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/ndv/","title":"ndv","text":""},{"location":"reference/ndv/#ndv","title":"ndv","text":"<p>Fast and flexible n-dimensional data viewer.</p> <p>Modules:</p> <ul> <li> <code>controllers</code>           \u2013            <p>Controllers are the primary public interfaces that wrap models &amp; views.</p> </li> <li> <code>data</code>           \u2013            <p>Sample data for testing and examples.</p> </li> <li> <code>models</code>           \u2013            <p>Models for <code>ndv</code>.</p> </li> <li> <code>util</code>           \u2013            <p>Utility and convenience functions.</p> </li> <li> <code>v1</code>           \u2013            <p>Here to allow access to the original (legacy) version of NDViewer.</p> </li> <li> <code>views</code>           \u2013            <p>Wrappers around GUI &amp; graphics frameworks.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>ArrayViewer</code>           \u2013            <p>Viewer dedicated to displaying a single n-dimensional array.</p> </li> <li> <code>DataWrapper</code>           \u2013            <p>Interface for wrapping different array-like data types.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>imshow</code>             \u2013              <p>Display an array or DataWrapper in a new NDViewer window.</p> </li> <li> <code>run_app</code>             \u2013              <p>Start the GUI application event loop.</p> </li> </ul>"},{"location":"reference/ndv/#ndv.ArrayViewer","title":"ArrayViewer","text":"<pre><code>ArrayViewer(data: Any | DataWrapper = None, /, display_model: ArrayDisplayModel | None = None, **kwargs: Unpack[ArrayDisplayModelKwargs])\n</code></pre> <p>Viewer dedicated to displaying a single n-dimensional array.</p> <p>This wraps a model and sview into a single object, and defines the public API.</p> <p>See also</p> <p><code>ndv.imshow</code> - a convenience function that constructs and shows an <code>ArrayViewer</code>.</p> <p>Future plans</p> <p>In the future, <code>ndv</code> would like to support multiple, layered data sources with coordinate transforms. We reserve the name <code>Viewer</code> for a more fully featured viewer. <code>ArrayViewer</code> assumes you're viewing a single array.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>clone</code>             \u2013              <p>Return a new ArrayViewer instance with the same data and display model.</p> </li> <li> <code>close</code>             \u2013              <p>Close the viewer.</p> </li> <li> <code>hide</code>             \u2013              <p>Show the viewer.</p> </li> <li> <code>show</code>             \u2013              <p>Show the viewer.</p> </li> <li> <code>widget</code>             \u2013              <p>Return the native front-end widget.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>Return data being displayed.</p> </li> <li> <code>data_wrapper</code>               (<code>Any</code>)           \u2013            <p>Return data being displayed.</p> </li> <li> <code>display_model</code>               (<code>ArrayDisplayModel</code>)           \u2013            <p>Return the current ArrayDisplayModel.</p> </li> </ul> Source code in <code>ndv/controllers/_array_viewer.py</code> <pre><code>def __init__(\n    self,\n    data: Any | DataWrapper = None,\n    /,\n    display_model: ArrayDisplayModel | None = None,\n    **kwargs: Unpack[ArrayDisplayModelKwargs],\n) -&gt; None:\n    if display_model is not None and kwargs:\n        warnings.warn(\n            \"When display_model is provided, kwargs are be ignored.\",\n            stacklevel=2,\n        )\n\n    # mapping of channel keys to their respective controllers\n    # where None is the default channel\n    self._lut_controllers: dict[LutKey, ChannelController] = {}\n\n    # get and create the front-end and canvas classes\n    frontend_cls = _app.get_array_view_class()\n    canvas_cls = _app.get_array_canvas_class()\n    self._canvas = canvas_cls()\n    self._canvas.set_ndim(2)\n\n    self._histogram: HistogramCanvas | None = None\n    self._view = frontend_cls(self._canvas.frontend_widget())\n\n    display_model = display_model or ArrayDisplayModel(**kwargs)\n    self._data_model = _ArrayDataDisplayModel(\n        data_wrapper=data, display=display_model\n    )\n    self._set_model_connected(self._data_model.display)\n\n    self._view.currentIndexChanged.connect(self._on_view_current_index_changed)\n    self._view.resetZoomClicked.connect(self._on_view_reset_zoom_clicked)\n    self._view.histogramRequested.connect(self._add_histogram)\n    self._view.channelModeChanged.connect(self._on_view_channel_mode_changed)\n    self._canvas.mouseMoved.connect(self._on_canvas_mouse_moved)\n\n    if self._data_model.data_wrapper is not None:\n        self._fully_synchronize_view()\n</code></pre>"},{"location":"reference/ndv/#ndv.ArrayViewer(data)","title":"<code>data</code>","text":"(<code> DataWrapper | Any</code>, default:                   <code>None</code> )           \u2013            <p>Data to be displayed.</p>"},{"location":"reference/ndv/#ndv.ArrayViewer(display_model)","title":"<code>display_model</code>","text":"(<code>ArrayDisplayModel</code>, default:                   <code>None</code> )           \u2013            <p>Just the display model to use. If provided, <code>data_or_model</code> must be an array or <code>DataWrapper</code>... and kwargs will be ignored.</p>"},{"location":"reference/ndv/#ndv.ArrayViewer(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Unpack[ArrayDisplayModelKwargs]</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the <code>ArrayDisplayModel</code> constructor. If <code>display_model</code> is provided, these will be ignored.</p>"},{"location":"reference/ndv/#ndv.ArrayViewer.data","title":"data  <code>property</code> <code>writable</code>","text":"<pre><code>data: Any\n</code></pre> <p>Return data being displayed.</p>"},{"location":"reference/ndv/#ndv.ArrayViewer.data_wrapper","title":"data_wrapper  <code>property</code>","text":"<pre><code>data_wrapper: Any\n</code></pre> <p>Return data being displayed.</p>"},{"location":"reference/ndv/#ndv.ArrayViewer.display_model","title":"display_model  <code>property</code> <code>writable</code>","text":"<pre><code>display_model: ArrayDisplayModel\n</code></pre> <p>Return the current ArrayDisplayModel.</p>"},{"location":"reference/ndv/#ndv.ArrayViewer.clone","title":"clone","text":"<pre><code>clone() -&gt; ArrayViewer\n</code></pre> <p>Return a new ArrayViewer instance with the same data and display model.</p> <p>Currently, this is a shallow copy.  Modifying one viewer will affect the state of the other.</p> Source code in <code>ndv/controllers/_array_viewer.py</code> <pre><code>def clone(self) -&gt; ArrayViewer:\n    \"\"\"Return a new ArrayViewer instance with the same data and display model.\n\n    Currently, this is a shallow copy.  Modifying one viewer will affect the state\n    of the other.\n    \"\"\"\n    # TODO: provide deep_copy option\n    return ArrayViewer(\n        self._data_model.data_wrapper, display_model=self.display_model\n    )\n</code></pre>"},{"location":"reference/ndv/#ndv.ArrayViewer.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the viewer.</p> Source code in <code>ndv/controllers/_array_viewer.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the viewer.\"\"\"\n    self._view.set_visible(False)\n</code></pre>"},{"location":"reference/ndv/#ndv.ArrayViewer.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Show the viewer.</p> Source code in <code>ndv/controllers/_array_viewer.py</code> <pre><code>def hide(self) -&gt; None:\n    \"\"\"Show the viewer.\"\"\"\n    self._view.set_visible(False)\n</code></pre>"},{"location":"reference/ndv/#ndv.ArrayViewer.show","title":"show","text":"<pre><code>show() -&gt; None\n</code></pre> <p>Show the viewer.</p> Source code in <code>ndv/controllers/_array_viewer.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Show the viewer.\"\"\"\n    self._view.set_visible(True)\n</code></pre>"},{"location":"reference/ndv/#ndv.ArrayViewer.widget","title":"widget","text":"<pre><code>widget() -&gt; Any\n</code></pre> <p>Return the native front-end widget.</p> <p>Warning</p> <p>If you directly manipulate the frontend widget, you're on your own . No guarantees can be made about synchronization with the model.  It is exposed for embedding in an application, and for experimentation and custom use cases.  Please open an issue if you have questions.</p> Source code in <code>ndv/controllers/_array_viewer.py</code> <pre><code>def widget(self) -&gt; Any:\n    \"\"\"Return the native front-end widget.\n\n    !!! Warning\n\n        If you directly manipulate the frontend widget, you're on your own :smile:.\n        No guarantees can be made about synchronization with the model.  It is\n        exposed for embedding in an application, and for experimentation and custom\n        use cases.  Please [open an\n        issue](https://github.com/pyapp-kit/ndv/issues/new) if you have questions.\n    \"\"\"\n    return self._view.frontend_widget()\n</code></pre>"},{"location":"reference/ndv/#ndv.DataWrapper","title":"DataWrapper","text":"<pre><code>DataWrapper(data: ArrayT)\n</code></pre> <p>               Bases: <code>Generic[ArrayT]</code>, <code>ABC</code></p> <p>Interface for wrapping different array-like data types.</p> <p><code>DataWrapper.create</code> is a factory method that returns a DataWrapper instance for the given data type. If your datastore type is not supported, you may implement a new DataWrapper subclass to handle your data type.  To do this, import and subclass DataWrapper, and (minimally) implement the supports and isel methods. Ensure that your class is imported before the DataWrapper.create method is called, and it will be automatically detected and used to wrap your data.</p> <p>Methods:</p> <ul> <li> <code>clear_cache</code>             \u2013              <p>Clear any cached properties.</p> </li> <li> <code>guess_channel_axis</code>             \u2013              <p>Return the (best guess) axis name for the channel dimension.</p> </li> <li> <code>isel</code>             \u2013              <p>Return a slice of the data as a numpy array.</p> </li> <li> <code>normalized_axis_key</code>             \u2013              <p>Return positive index for <code>axis</code> (which can be +/- int or str label).</p> </li> <li> <code>sizes</code>             \u2013              <p>Return the sizes of the dimensions.</p> </li> <li> <code>summary_info</code>             \u2013              <p>Return info label with information about the data.</p> </li> <li> <code>supports</code>             \u2013              <p>Return True if this wrapper can handle the given object.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>axis_map</code>               (<code>Mapping[Hashable, int]</code>)           \u2013            <p>Mapping of ALL valid axis keys to normalized, positive integer keys.</p> </li> <li> <code>coords</code>               (<code>Mapping[Hashable, Sequence]</code>)           \u2013            <p>Return the coordinates for the data.</p> </li> <li> <code>data</code>               (<code>ArrayT</code>)           \u2013            <p>Return the data being wrapped.</p> </li> <li> <code>dims</code>               (<code>tuple[Hashable, ...]</code>)           \u2013            <p>Return the dimension labels for the data.</p> </li> <li> <code>dtype</code>               (<code>dtype</code>)           \u2013            <p>Return the dtype for the data.</p> </li> </ul> Source code in <code>ndv/models/_data_wrapper.py</code> <pre><code>def __init__(self, data: ArrayT) -&gt; None:\n    self._data = data\n</code></pre>"},{"location":"reference/ndv/#ndv.DataWrapper.axis_map","title":"axis_map  <code>cached</code> <code>property</code>","text":"<pre><code>axis_map: Mapping[Hashable, int]\n</code></pre> <p>Mapping of ALL valid axis keys to normalized, positive integer keys.</p>"},{"location":"reference/ndv/#ndv.DataWrapper.coords","title":"coords  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>coords: Mapping[Hashable, Sequence]\n</code></pre> <p>Return the coordinates for the data.</p>"},{"location":"reference/ndv/#ndv.DataWrapper.data","title":"data  <code>property</code>","text":"<pre><code>data: ArrayT\n</code></pre> <p>Return the data being wrapped.</p>"},{"location":"reference/ndv/#ndv.DataWrapper.dims","title":"dims  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>dims: tuple[Hashable, ...]\n</code></pre> <p>Return the dimension labels for the data.</p>"},{"location":"reference/ndv/#ndv.DataWrapper.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: dtype\n</code></pre> <p>Return the dtype for the data.</p>"},{"location":"reference/ndv/#ndv.DataWrapper.clear_cache","title":"clear_cache","text":"<pre><code>clear_cache() -&gt; None\n</code></pre> <p>Clear any cached properties.</p> Source code in <code>ndv/models/_data_wrapper.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear any cached properties.\"\"\"\n    if hasattr(self, \"axis_map\"):\n        del self.axis_map\n</code></pre>"},{"location":"reference/ndv/#ndv.DataWrapper.guess_channel_axis","title":"guess_channel_axis","text":"<pre><code>guess_channel_axis() -&gt; Hashable | None\n</code></pre> <p>Return the (best guess) axis name for the channel dimension.</p> Source code in <code>ndv/models/_data_wrapper.py</code> <pre><code>def guess_channel_axis(self) -&gt; Hashable | None:\n    \"\"\"Return the (best guess) axis name for the channel dimension.\"\"\"\n    # for arrays with labeled dimensions,\n    # see if any of the dimensions are named \"channel\"\n    sizes = self.sizes()\n    for dimkey, val in sizes.items():\n        if str(dimkey).lower() in self.COMMON_CHANNEL_NAMES:\n            if val &lt;= self.MAX_CHANNELS:\n                return self.normalized_axis_key(dimkey)\n\n    # otherwise use the smallest dimension as the channel axis\n    return min(sizes, key=sizes.get)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/ndv/#ndv.DataWrapper.isel","title":"isel  <code>abstractmethod</code>","text":"<pre><code>isel(index: Mapping[int, int | slice]) -&gt; ndarray\n</code></pre> <p>Return a slice of the data as a numpy array.</p> Source code in <code>ndv/models/_data_wrapper.py</code> <pre><code>@abstractmethod\ndef isel(self, index: Mapping[int, int | slice]) -&gt; np.ndarray:\n    \"\"\"Return a slice of the data as a numpy array.\"\"\"\n</code></pre>"},{"location":"reference/ndv/#ndv.DataWrapper.normalized_axis_key","title":"normalized_axis_key","text":"<pre><code>normalized_axis_key(axis: Hashable) -&gt; int\n</code></pre> <p>Return positive index for <code>axis</code> (which can be +/- int or str label).</p> Source code in <code>ndv/models/_data_wrapper.py</code> <pre><code>def normalized_axis_key(self, axis: Hashable) -&gt; int:\n    \"\"\"Return positive index for `axis` (which can be +/- int or str label).\"\"\"\n    try:\n        return self.axis_map[axis]\n    except KeyError as e:\n        ndims = len(self.dims)\n        if isinstance(axis, int):\n            raise IndexError(\n                f\"Axis index {axis} out of bounds for data with {ndims} dimensions\"\n            ) from e\n        raise IndexError(f\"Axis label {axis} not found in data dimensions\") from e\n</code></pre>"},{"location":"reference/ndv/#ndv.DataWrapper.sizes","title":"sizes","text":"<pre><code>sizes() -&gt; Mapping[Hashable, int]\n</code></pre> <p>Return the sizes of the dimensions.</p> Source code in <code>ndv/models/_data_wrapper.py</code> <pre><code>def sizes(self) -&gt; Mapping[Hashable, int]:\n    \"\"\"Return the sizes of the dimensions.\"\"\"\n    return {dim: len(self.coords[dim]) for dim in self.dims}\n</code></pre>"},{"location":"reference/ndv/#ndv.DataWrapper.summary_info","title":"summary_info","text":"<pre><code>summary_info() -&gt; str\n</code></pre> <p>Return info label with information about the data.</p> Source code in <code>ndv/models/_data_wrapper.py</code> <pre><code>def summary_info(self) -&gt; str:\n    \"\"\"Return info label with information about the data.\"\"\"\n    package = getattr(self._data, \"__module__\", \"\").split(\".\")[0]\n    info = f\"{package}.{getattr(type(self._data), '__qualname__', '')}\"\n\n    if sizes := self.sizes():\n        # if all of the dimension keys are just integers, omit them from size_str\n        if all(isinstance(x, int) for x in sizes):\n            size_str = repr(tuple(sizes.values()))\n        # otherwise, include the keys in the size_str\n        else:\n            size_str = \", \".join(f\"{k}:{v}\" for k, v in sizes.items())\n            size_str = f\"({size_str})\"\n        info += f\" {size_str}\"\n    if dtype := getattr(self._data, \"dtype\", \"\"):\n        info += f\", {dtype}\"\n    if nbytes := getattr(self._data, \"nbytes\", 0) / 1e6:\n        info += f\", {nbytes:.2f}MB\"\n    return info\n</code></pre>"},{"location":"reference/ndv/#ndv.DataWrapper.supports","title":"supports  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>supports(obj: Any) -&gt; bool\n</code></pre> <p>Return True if this wrapper can handle the given object.</p> <p>Any exceptions raised by this method will be suppressed, so it is safe to directly import necessary dependencies without a try/except block.</p> Source code in <code>ndv/models/_data_wrapper.py</code> <pre><code>@classmethod\n@abstractmethod\ndef supports(cls, obj: Any) -&gt; bool:\n    \"\"\"Return True if this wrapper can handle the given object.\n\n    Any exceptions raised by this method will be suppressed, so it is safe to\n    directly import necessary dependencies without a try/except block.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/#ndv.imshow","title":"imshow","text":"<pre><code>imshow(data: Any | DataWrapper, /, display_model: ArrayDisplayModel = ...) -&gt; ArrayViewer\n</code></pre><pre><code>imshow(data: Any | DataWrapper, /, **kwargs: Unpack[ArrayDisplayModelKwargs]) -&gt; ArrayViewer\n</code></pre> <pre><code>imshow(data: Any | DataWrapper, /, display_model: ArrayDisplayModel | None = None, **kwargs: Unpack[ArrayDisplayModelKwargs]) -&gt; ArrayViewer\n</code></pre> <p>Display an array or DataWrapper in a new NDViewer window.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ArrayViewer</code>           \u2013            <p>The viewer window.</p> </li> </ul> Source code in <code>ndv/util.py</code> <pre><code>def imshow(\n    data: Any | DataWrapper,\n    /,\n    display_model: ArrayDisplayModel | None = None,\n    **kwargs: Unpack[ArrayDisplayModelKwargs],\n) -&gt; ArrayViewer:\n    \"\"\"Display an array or DataWrapper in a new NDViewer window.\n\n    Parameters\n    ----------\n    data : Any | DataWrapper\n        The data to be displayed. Any ArrayLike object or an `ndv.DataWrapper`.\n    display_model: ArrayDisplayModel, optional\n        The display model to use. If not provided, a new one will be created.\n    kwargs : Unpack[ArrayDisplayModelKwargs]\n        Additional keyword arguments to pass to the NDViewer\n\n    Returns\n    -------\n    ArrayViewer\n        The viewer window.\n    \"\"\"\n    viewer = ArrayViewer(data, display_model, **kwargs)\n    viewer.show()\n\n    run_app()\n    return viewer\n</code></pre>"},{"location":"reference/ndv/#ndv.imshow(data)","title":"<code>data</code>","text":"(<code>Any | DataWrapper</code>)           \u2013            <p>The data to be displayed. Any ArrayLike object or an <code>ndv.DataWrapper</code>.</p>"},{"location":"reference/ndv/#ndv.imshow(display_model)","title":"<code>display_model</code>","text":"(<code>ArrayDisplayModel | None</code>, default:                   <code>None</code> )           \u2013            <p>The display model to use. If not provided, a new one will be created.</p>"},{"location":"reference/ndv/#ndv.imshow(kwargs)","title":"<code>kwargs</code>","text":"(<code>Unpack[ArrayDisplayModelKwargs]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the NDViewer</p>"},{"location":"reference/ndv/#ndv.run_app","title":"run_app","text":"<pre><code>run_app() -&gt; None\n</code></pre> <p>Start the GUI application event loop.</p> Source code in <code>ndv/views/_app.py</code> <pre><code>def run_app() -&gt; None:\n    \"\"\"Start the GUI application event loop.\"\"\"\n    GUI_PROVIDERS[gui_frontend()].exec()\n</code></pre>"},{"location":"reference/ndv/data/","title":"ndv.data","text":""},{"location":"reference/ndv/data/#ndv.data","title":"ndv.data","text":"<p>Sample data for testing and examples.</p> <p>Functions:</p> <ul> <li> <code>astronaut</code>             \u2013              <p>Load RGB data <code>(512, 512, 3)</code>, uint8.</p> </li> <li> <code>cat</code>             \u2013              <p>Load RGB cat data <code>(300, 451, 3)</code>, uint8.</p> </li> <li> <code>cells3d</code>             \u2013              <p>Load cells3d from scikit-image <code>(60, 2, 256, 256)</code> uint16.</p> </li> <li> <code>cosem_dataset</code>             \u2013              <p>Load a dataset from the COSEM/OpenOrganelle project.</p> </li> <li> <code>nd_sine_wave</code>             \u2013              <p>5D dataset: <code>(10, 3, 5, 512, 512)</code>, float64.</p> </li> </ul>"},{"location":"reference/ndv/data/#ndv.data.astronaut","title":"astronaut","text":"<pre><code>astronaut() -&gt; ndarray\n</code></pre> <p>Load RGB data <code>(512, 512, 3)</code>, uint8.</p> <p>Requires imageio to be installed.</p> Source code in <code>ndv/data.py</code> <pre><code>def astronaut() -&gt; np.ndarray:\n    \"\"\"Load RGB data `(512, 512, 3)`, uint8.\n\n    Requires [imageio](https://pypi.org/project/imageio/) to be installed.\n    \"\"\"\n    return _imread(\"imageio:astronaut.png\")\n</code></pre>"},{"location":"reference/ndv/data/#ndv.data.cat","title":"cat","text":"<pre><code>cat() -&gt; ndarray\n</code></pre> <p>Load RGB cat data <code>(300, 451, 3)</code>, uint8.</p> <p>Requires imageio to be installed.</p> Source code in <code>ndv/data.py</code> <pre><code>def cat() -&gt; np.ndarray:\n    \"\"\"Load RGB cat data `(300, 451, 3)`, uint8.\n\n    Requires [imageio](https://pypi.org/project/imageio/) to be installed.\n    \"\"\"\n    return _imread(\"imageio:chelsea.png\")\n</code></pre>"},{"location":"reference/ndv/data/#ndv.data.cells3d","title":"cells3d","text":"<pre><code>cells3d() -&gt; ndarray\n</code></pre> <p>Load cells3d from scikit-image <code>(60, 2, 256, 256)</code> uint16.</p> <p>Requires <code>imageio and tifffile</code> to be installed.</p> Source code in <code>ndv/data.py</code> <pre><code>def cells3d() -&gt; np.ndarray:\n    \"\"\"Load cells3d from scikit-image `(60, 2, 256, 256)` uint16.\n\n    Requires `imageio and tifffile` to be installed.\n    \"\"\"\n    try:\n        from imageio.v2 import volread\n    except ImportError as e:\n        raise ImportError(\n            \"Please `pip install imageio[tifffile]` to load cells3d\"\n        ) from e\n\n    url = \"https://gitlab.com/scikit-image/data/-/raw/2cdc5ce89b334d28f06a58c9f0ca21aa6992a5ba/cells3d.tif\"\n    data = np.asarray(volread(url))\n\n    # this data has been stretched to 16 bit, and lacks certain intensity values\n    # add a small random integer to each pixel ... so the histogram is not silly\n    data = (data + np.random.randint(-24, 24, data.shape)).astype(np.uint16)\n    return data\n</code></pre>"},{"location":"reference/ndv/data/#ndv.data.cosem_dataset","title":"cosem_dataset","text":"<pre><code>cosem_dataset(uri: str = '', dataset: str = 'jrc_hela-3', label: str = 'er-mem_pred', level: int = 4) -&gt; Any\n</code></pre> <p>Load a dataset from the COSEM/OpenOrganelle project.</p> <p>Search for available options at: https://openorganelle.janelia.org/datasets</p> <p>Requires tensorstore to be installed.</p> <p>Parameters:</p> Source code in <code>ndv/data.py</code> <pre><code>def cosem_dataset(\n    uri: str = \"\",\n    dataset: str = \"jrc_hela-3\",\n    label: str = \"er-mem_pred\",\n    level: int = 4,\n) -&gt; Any:\n    \"\"\"Load a dataset from the COSEM/OpenOrganelle project.\n\n    Search for available options at: &lt;https://openorganelle.janelia.org/datasets&gt;\n\n    Requires [tensorstore](https://pypi.org/project/tensorstore/) to be installed.\n\n    Parameters\n    ----------\n    uri : str, optional\n        The URI of the dataset to load. If not provided, the default URI is\n        `f\"{dataset}/{dataset}.n5/labels/{label}/s{level}/\"`.\n    dataset : str, optional\n        The name of the dataset to load. Default is \"jrc_hela-3\".\n    label : str, optional\n        The label to load. Default is \"er-mem_pred\".\n    level : int, optional\n        The pyramid level to load. Default is 4.\n    \"\"\"\n    try:\n        import tensorstore as ts\n    except ImportError:\n        raise ImportError(\"Please install tensorstore to fetch cosem data\") from None\n\n    if not uri:\n        uri = f\"{dataset}/{dataset}.n5/labels/{label}/s{level}/\"\n\n    ts_array = ts.open(\n        {\n            \"driver\": \"n5\",\n            \"kvstore\": {\n                \"driver\": \"s3\",\n                \"bucket\": \"janelia-cosem-datasets\",\n                \"path\": uri,\n            },\n        },\n    ).result()\n    ts_array = ts_array[ts.d[:].label[\"z\", \"y\", \"x\"]]\n    return ts_array[ts.d[(\"y\", \"x\", \"z\")].transpose[:]]\n</code></pre>"},{"location":"reference/ndv/data/#ndv.data.cosem_dataset(uri)","title":"<code>uri</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The URI of the dataset to load. If not provided, the default URI is <code>f\"{dataset}/{dataset}.n5/labels/{label}/s{level}/\"</code>.</p>"},{"location":"reference/ndv/data/#ndv.data.cosem_dataset(dataset)","title":"<code>dataset</code>","text":"(<code>str</code>, default:                   <code>'jrc_hela-3'</code> )           \u2013            <p>The name of the dataset to load. Default is \"jrc_hela-3\".</p>"},{"location":"reference/ndv/data/#ndv.data.cosem_dataset(label)","title":"<code>label</code>","text":"(<code>str</code>, default:                   <code>'er-mem_pred'</code> )           \u2013            <p>The label to load. Default is \"er-mem_pred\".</p>"},{"location":"reference/ndv/data/#ndv.data.cosem_dataset(level)","title":"<code>level</code>","text":"(<code>int</code>, default:                   <code>4</code> )           \u2013            <p>The pyramid level to load. Default is 4.</p>"},{"location":"reference/ndv/data/#ndv.data.nd_sine_wave","title":"nd_sine_wave","text":"<pre><code>nd_sine_wave(shape: tuple[int, int, int, int, int] = (10, 3, 5, 512, 512), amplitude: float = 240, base_frequency: float = 5) -&gt; ndarray\n</code></pre> <p>5D dataset: <code>(10, 3, 5, 512, 512)</code>, float64.</p> Source code in <code>ndv/data.py</code> <pre><code>def nd_sine_wave(\n    shape: tuple[int, int, int, int, int] = (10, 3, 5, 512, 512),\n    amplitude: float = 240,\n    base_frequency: float = 5,\n) -&gt; np.ndarray:\n    \"\"\"5D dataset: `(10, 3, 5, 512, 512)`, float64.\"\"\"\n    # Unpack the dimensions\n    if not len(shape) == 5:\n        raise ValueError(\"Shape must have 5 dimensions\")\n    angle_dim, freq_dim, phase_dim, ny, nx = shape\n\n    # Create an empty array to hold the data\n    output = np.zeros(shape)\n\n    # Define spatial coordinates for the last two dimensions\n    half_per = base_frequency * np.pi\n    x = np.linspace(-half_per, half_per, nx)\n    y = np.linspace(-half_per, half_per, ny)\n    y, x = np.meshgrid(y, x)\n\n    # Iterate through each parameter in the higher dimensions\n    for phase_idx in range(phase_dim):\n        for freq_idx in range(freq_dim):\n            for angle_idx in range(angle_dim):\n                # Calculate phase and frequency\n                phase = np.pi / phase_dim * phase_idx\n                frequency = 1 + (freq_idx * 0.1)  # Increasing frequency with each step\n\n                # Calculate angle\n                angle = np.pi / angle_dim * angle_idx\n                # Rotate x and y coordinates\n                xr = np.cos(angle) * x - np.sin(angle) * y\n                np.sin(angle) * x + np.cos(angle) * y\n\n                # Compute the sine wave\n                sine_wave = (amplitude * 0.5) * np.sin(frequency * xr + phase)\n                sine_wave += amplitude * 0.5\n\n                # Assign to the output array\n                output[angle_idx, freq_idx, phase_idx] = sine_wave\n\n    return output\n</code></pre>"},{"location":"reference/ndv/util/","title":"ndv.util","text":""},{"location":"reference/ndv/util/#ndv.util","title":"ndv.util","text":"<p>Utility and convenience functions.</p> <p>Functions:</p> <ul> <li> <code>imshow</code>             \u2013              <p>Display an array or DataWrapper in a new NDViewer window.</p> </li> </ul>"},{"location":"reference/ndv/util/#ndv.util.imshow","title":"imshow","text":"<pre><code>imshow(data: Any | DataWrapper, /, display_model: ArrayDisplayModel = ...) -&gt; ArrayViewer\n</code></pre><pre><code>imshow(data: Any | DataWrapper, /, **kwargs: Unpack[ArrayDisplayModelKwargs]) -&gt; ArrayViewer\n</code></pre> <pre><code>imshow(data: Any | DataWrapper, /, display_model: ArrayDisplayModel | None = None, **kwargs: Unpack[ArrayDisplayModelKwargs]) -&gt; ArrayViewer\n</code></pre> <p>Display an array or DataWrapper in a new NDViewer window.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ArrayViewer</code>           \u2013            <p>The viewer window.</p> </li> </ul> Source code in <code>ndv/util.py</code> <pre><code>def imshow(\n    data: Any | DataWrapper,\n    /,\n    display_model: ArrayDisplayModel | None = None,\n    **kwargs: Unpack[ArrayDisplayModelKwargs],\n) -&gt; ArrayViewer:\n    \"\"\"Display an array or DataWrapper in a new NDViewer window.\n\n    Parameters\n    ----------\n    data : Any | DataWrapper\n        The data to be displayed. Any ArrayLike object or an `ndv.DataWrapper`.\n    display_model: ArrayDisplayModel, optional\n        The display model to use. If not provided, a new one will be created.\n    kwargs : Unpack[ArrayDisplayModelKwargs]\n        Additional keyword arguments to pass to the NDViewer\n\n    Returns\n    -------\n    ArrayViewer\n        The viewer window.\n    \"\"\"\n    viewer = ArrayViewer(data, display_model, **kwargs)\n    viewer.show()\n\n    run_app()\n    return viewer\n</code></pre>"},{"location":"reference/ndv/util/#ndv.util.imshow(data)","title":"<code>data</code>","text":"(<code>Any | DataWrapper</code>)           \u2013            <p>The data to be displayed. Any ArrayLike object or an <code>ndv.DataWrapper</code>.</p>"},{"location":"reference/ndv/util/#ndv.util.imshow(display_model)","title":"<code>display_model</code>","text":"(<code>ArrayDisplayModel | None</code>, default:                   <code>None</code> )           \u2013            <p>The display model to use. If not provided, a new one will be created.</p>"},{"location":"reference/ndv/util/#ndv.util.imshow(kwargs)","title":"<code>kwargs</code>","text":"(<code>Unpack[ArrayDisplayModelKwargs]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the NDViewer</p>"},{"location":"reference/ndv/controllers/","title":"ndv.controllers","text":""},{"location":"reference/ndv/controllers/#ndv.controllers","title":"ndv.controllers","text":"<p>Controllers are the primary public interfaces that wrap models &amp; views.</p> <p>Classes:</p> <ul> <li> <code>ArrayViewer</code>           \u2013            <p>Viewer dedicated to displaying a single n-dimensional array.</p> </li> </ul>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer","title":"ArrayViewer","text":"<pre><code>ArrayViewer(data: Any | DataWrapper = None, /, display_model: ArrayDisplayModel | None = None, **kwargs: Unpack[ArrayDisplayModelKwargs])\n</code></pre> <p>Viewer dedicated to displaying a single n-dimensional array.</p> <p>This wraps a model and sview into a single object, and defines the public API.</p> <p>See also</p> <p><code>ndv.imshow</code> - a convenience function that constructs and shows an <code>ArrayViewer</code>.</p> <p>Future plans</p> <p>In the future, <code>ndv</code> would like to support multiple, layered data sources with coordinate transforms. We reserve the name <code>Viewer</code> for a more fully featured viewer. <code>ArrayViewer</code> assumes you're viewing a single array.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>clone</code>             \u2013              <p>Return a new ArrayViewer instance with the same data and display model.</p> </li> <li> <code>close</code>             \u2013              <p>Close the viewer.</p> </li> <li> <code>hide</code>             \u2013              <p>Show the viewer.</p> </li> <li> <code>show</code>             \u2013              <p>Show the viewer.</p> </li> <li> <code>widget</code>             \u2013              <p>Return the native front-end widget.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>Return data being displayed.</p> </li> <li> <code>data_wrapper</code>               (<code>Any</code>)           \u2013            <p>Return data being displayed.</p> </li> <li> <code>display_model</code>               (<code>ArrayDisplayModel</code>)           \u2013            <p>Return the current ArrayDisplayModel.</p> </li> </ul> Source code in <code>ndv/controllers/_array_viewer.py</code> <pre><code>def __init__(\n    self,\n    data: Any | DataWrapper = None,\n    /,\n    display_model: ArrayDisplayModel | None = None,\n    **kwargs: Unpack[ArrayDisplayModelKwargs],\n) -&gt; None:\n    if display_model is not None and kwargs:\n        warnings.warn(\n            \"When display_model is provided, kwargs are be ignored.\",\n            stacklevel=2,\n        )\n\n    # mapping of channel keys to their respective controllers\n    # where None is the default channel\n    self._lut_controllers: dict[LutKey, ChannelController] = {}\n\n    # get and create the front-end and canvas classes\n    frontend_cls = _app.get_array_view_class()\n    canvas_cls = _app.get_array_canvas_class()\n    self._canvas = canvas_cls()\n    self._canvas.set_ndim(2)\n\n    self._histogram: HistogramCanvas | None = None\n    self._view = frontend_cls(self._canvas.frontend_widget())\n\n    display_model = display_model or ArrayDisplayModel(**kwargs)\n    self._data_model = _ArrayDataDisplayModel(\n        data_wrapper=data, display=display_model\n    )\n    self._set_model_connected(self._data_model.display)\n\n    self._view.currentIndexChanged.connect(self._on_view_current_index_changed)\n    self._view.resetZoomClicked.connect(self._on_view_reset_zoom_clicked)\n    self._view.histogramRequested.connect(self._add_histogram)\n    self._view.channelModeChanged.connect(self._on_view_channel_mode_changed)\n    self._canvas.mouseMoved.connect(self._on_canvas_mouse_moved)\n\n    if self._data_model.data_wrapper is not None:\n        self._fully_synchronize_view()\n</code></pre>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer(data)","title":"<code>data</code>","text":"(<code> DataWrapper | Any</code>, default:                   <code>None</code> )           \u2013            <p>Data to be displayed.</p>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer(display_model)","title":"<code>display_model</code>","text":"(<code>ArrayDisplayModel</code>, default:                   <code>None</code> )           \u2013            <p>Just the display model to use. If provided, <code>data_or_model</code> must be an array or <code>DataWrapper</code>... and kwargs will be ignored.</p>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Unpack[ArrayDisplayModelKwargs]</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the <code>ArrayDisplayModel</code> constructor. If <code>display_model</code> is provided, these will be ignored.</p>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer.data","title":"data  <code>property</code> <code>writable</code>","text":"<pre><code>data: Any\n</code></pre> <p>Return data being displayed.</p>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer.data_wrapper","title":"data_wrapper  <code>property</code>","text":"<pre><code>data_wrapper: Any\n</code></pre> <p>Return data being displayed.</p>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer.display_model","title":"display_model  <code>property</code> <code>writable</code>","text":"<pre><code>display_model: ArrayDisplayModel\n</code></pre> <p>Return the current ArrayDisplayModel.</p>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer.clone","title":"clone","text":"<pre><code>clone() -&gt; ArrayViewer\n</code></pre> <p>Return a new ArrayViewer instance with the same data and display model.</p> <p>Currently, this is a shallow copy.  Modifying one viewer will affect the state of the other.</p> Source code in <code>ndv/controllers/_array_viewer.py</code> <pre><code>def clone(self) -&gt; ArrayViewer:\n    \"\"\"Return a new ArrayViewer instance with the same data and display model.\n\n    Currently, this is a shallow copy.  Modifying one viewer will affect the state\n    of the other.\n    \"\"\"\n    # TODO: provide deep_copy option\n    return ArrayViewer(\n        self._data_model.data_wrapper, display_model=self.display_model\n    )\n</code></pre>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the viewer.</p> Source code in <code>ndv/controllers/_array_viewer.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the viewer.\"\"\"\n    self._view.set_visible(False)\n</code></pre>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Show the viewer.</p> Source code in <code>ndv/controllers/_array_viewer.py</code> <pre><code>def hide(self) -&gt; None:\n    \"\"\"Show the viewer.\"\"\"\n    self._view.set_visible(False)\n</code></pre>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer.show","title":"show","text":"<pre><code>show() -&gt; None\n</code></pre> <p>Show the viewer.</p> Source code in <code>ndv/controllers/_array_viewer.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Show the viewer.\"\"\"\n    self._view.set_visible(True)\n</code></pre>"},{"location":"reference/ndv/controllers/#ndv.controllers.ArrayViewer.widget","title":"widget","text":"<pre><code>widget() -&gt; Any\n</code></pre> <p>Return the native front-end widget.</p> <p>Warning</p> <p>If you directly manipulate the frontend widget, you're on your own . No guarantees can be made about synchronization with the model.  It is exposed for embedding in an application, and for experimentation and custom use cases.  Please open an issue if you have questions.</p> Source code in <code>ndv/controllers/_array_viewer.py</code> <pre><code>def widget(self) -&gt; Any:\n    \"\"\"Return the native front-end widget.\n\n    !!! Warning\n\n        If you directly manipulate the frontend widget, you're on your own :smile:.\n        No guarantees can be made about synchronization with the model.  It is\n        exposed for embedding in an application, and for experimentation and custom\n        use cases.  Please [open an\n        issue](https://github.com/pyapp-kit/ndv/issues/new) if you have questions.\n    \"\"\"\n    return self._view.frontend_widget()\n</code></pre>"},{"location":"reference/ndv/models/","title":"ndv.models","text":""},{"location":"reference/ndv/models/#ndv.models","title":"ndv.models","text":"<p>Models for <code>ndv</code>.</p> <p>Classes:</p> <ul> <li> <code>ArrayDisplayModel</code>           \u2013            <p>Model of how to display an array.</p> </li> <li> <code>ChannelMode</code>           \u2013            <p>Channel display mode.</p> </li> <li> <code>DataWrapper</code>           \u2013            <p>Interface for wrapping different array-like data types.</p> </li> <li> <code>LUTModel</code>           \u2013            <p>Representation of how to display a channel of an array.</p> </li> </ul>"},{"location":"reference/ndv/models/#ndv.models.ArrayDisplayModel","title":"ArrayDisplayModel","text":"<p>               Bases: <code>NDVModel</code></p> <p>Model of how to display an array.</p> <p>In the following types, <code>AxisKey</code> can be either an integer index or a string label.</p> <p>Attributes:</p> <ul> <li> <code>visible_axes</code>               (<code>tuple[AxisKey, ...]</code>)           \u2013            <p>Ordered list of axes to visualize, from slowest to fastest. e.g. ('z', -2, -1)</p> </li> <li> <code>current_index</code>               (<code>Mapping[AxisKey, int | Slice]</code>)           \u2013            <p>The currently displayed position/slice along each dimension. e.g. {0: 0, 'time': slice(10, 20)} Not all axes need be present, and axes not present are assumed to be slice(None), meaning it is up to the controller of this model to restrict indices to an efficient range for retrieval. If the number of non-singleton axes is greater than <code>n_visible_axes</code>, then reducers are used to reduce the data along the remaining axes. NOTE: In terms of requesting data, there is a slight \"delocalization\" of state here in that we probably also want to avoid requesting data for channel positions that are not visible.</p> </li> <li> <code>reducers</code>               (<code>Mapping[AxisKey | None, ReducerType]</code>)           \u2013            <p>Callable to reduce data along axes remaining after slicing. Ideally, the ufunc should accept an <code>axis</code> argument. (TODO: what happens if not?)</p> </li> <li> <code>channel_mode</code>               (<code>ChannelMode</code>)           \u2013            <p>How to display channel information:     - <code>GRAYSCALE</code>: ignore channel axis, use <code>default_lut</code>     - <code>COMPOSITE</code>: display all channels as a composite image, using <code>luts</code>     - <code>COLOR</code>: display a single channel at a time, using <code>luts</code>     - <code>RGBA</code>: display as an RGB image, using <code>default_lut</code> (except for cmap)</p> <p>If <code>channel_mode</code> is set to anything other than <code>GRAYSCALE</code>, then <code>channel_axis</code> must be set to a valid axis; if no <code>channel_axis</code> is set, at the time of display, the <code>DataWrapper</code> MAY guess the <code>channel_axis</code>, and set it on the model.</p> </li> <li> <code>channel_axis</code>               (<code>AxisKey | None</code>)           \u2013            <p>The dimension index or name of the channel dimension. The implication of setting channel_axis is that all elements along the channel dimension are shown, with different LUTs applied to each channel. If None, then a single lookup table is used for all channels (<code>luts[None]</code>). NOTE: it is an error for channel_axis to be in <code>visible_axes</code> (or ignore it?)</p> </li> <li> <code>luts</code>               (<code>Mapping[int | None, LUTModel]</code>)           \u2013            <p>Instructions for how to display each channel of the array. Keys represent position along the dimension specified by <code>channel_axis</code>. Values are <code>LUT</code> objects that specify how to display the channel. The special key <code>None</code> is used to represent a fallback LUT for all channels, and is used when <code>channel_axis</code> is None.  It should always be present</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>n_visible_axes</code>               (<code>Literal[2, 3]</code>)           \u2013            <p>Number of dims is derived from the length of <code>visible_axes</code>.</p> </li> </ul>"},{"location":"reference/ndv/models/#ndv.models.ArrayDisplayModel.n_visible_axes","title":"n_visible_axes  <code>property</code>","text":"<pre><code>n_visible_axes: Literal[2, 3]\n</code></pre> <p>Number of dims is derived from the length of <code>visible_axes</code>.</p>"},{"location":"reference/ndv/models/#ndv.models.ChannelMode","title":"ChannelMode","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Channel display mode.</p> <p>Attributes:</p> <ul> <li> <code>GRAYSCALE</code>               (<code>str</code>)           \u2013            <p>The array is displayed as a single channel, with a single lookup table applied. In this mode, there effective is no channel axis: all non-visible dimensions have sliders, and there is a single LUT control (the <code>default_lut</code>).</p> </li> <li> <code>COMPOSITE</code>               (<code>str</code>)           \u2013            <p>Display all (or a subset of) channels as a composite image, with a different lookup table applied to each channel.  In this mode, the slider for the channel axis is hidden by default, and LUT controls for each channel are shown.</p> </li> <li> <code>COLOR</code>               (<code>str</code>)           \u2013            <p>Display a single channel at a time as a color image, with a channel-specific lookup table applied.  In this mode, the slider for the channel axis is shown, and the user can select which channel to display.  LUT controls are shown for all channels.</p> </li> <li> <code>RGBA</code>               (<code>str</code>)           \u2013            <p>The array is displayed as an RGB image, with a single lookup table applied. In this mode, the slider for the channel axis is hidden, and a single LUT control is shown. Only valid when channel axis has length &lt;= 4.</p> </li> <li> <code>RGB</code>               (<code>str</code>)           \u2013            <p>Alias for RGBA.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>is_multichannel</code>             \u2013              <p>Return whether this mode displays multiple channels.</p> </li> </ul>"},{"location":"reference/ndv/models/#ndv.models.ChannelMode.is_multichannel","title":"is_multichannel","text":"<pre><code>is_multichannel() -&gt; bool\n</code></pre> <p>Return whether this mode displays multiple channels.</p> <p>If <code>is_multichannel</code> is True, then the <code>channel_axis</code> slider should be hidden.</p> Source code in <code>ndv/models/_array_display_model.py</code> <pre><code>def is_multichannel(self) -&gt; bool:\n    \"\"\"Return whether this mode displays multiple channels.\n\n    If `is_multichannel` is True, then the `channel_axis` slider should be hidden.\n    \"\"\"\n    return self in (ChannelMode.COMPOSITE, ChannelMode.RGBA)\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper","title":"DataWrapper","text":"<pre><code>DataWrapper(data: ArrayT)\n</code></pre> <p>               Bases: <code>Generic[ArrayT]</code>, <code>ABC</code></p> <p>Interface for wrapping different array-like data types.</p> <p><code>DataWrapper.create</code> is a factory method that returns a DataWrapper instance for the given data type. If your datastore type is not supported, you may implement a new DataWrapper subclass to handle your data type.  To do this, import and subclass DataWrapper, and (minimally) implement the supports and isel methods. Ensure that your class is imported before the DataWrapper.create method is called, and it will be automatically detected and used to wrap your data.</p> <p>Methods:</p> <ul> <li> <code>clear_cache</code>             \u2013              <p>Clear any cached properties.</p> </li> <li> <code>guess_channel_axis</code>             \u2013              <p>Return the (best guess) axis name for the channel dimension.</p> </li> <li> <code>isel</code>             \u2013              <p>Return a slice of the data as a numpy array.</p> </li> <li> <code>normalized_axis_key</code>             \u2013              <p>Return positive index for <code>axis</code> (which can be +/- int or str label).</p> </li> <li> <code>sizes</code>             \u2013              <p>Return the sizes of the dimensions.</p> </li> <li> <code>summary_info</code>             \u2013              <p>Return info label with information about the data.</p> </li> <li> <code>supports</code>             \u2013              <p>Return True if this wrapper can handle the given object.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>axis_map</code>               (<code>Mapping[Hashable, int]</code>)           \u2013            <p>Mapping of ALL valid axis keys to normalized, positive integer keys.</p> </li> <li> <code>coords</code>               (<code>Mapping[Hashable, Sequence]</code>)           \u2013            <p>Return the coordinates for the data.</p> </li> <li> <code>data</code>               (<code>ArrayT</code>)           \u2013            <p>Return the data being wrapped.</p> </li> <li> <code>dims</code>               (<code>tuple[Hashable, ...]</code>)           \u2013            <p>Return the dimension labels for the data.</p> </li> <li> <code>dtype</code>               (<code>dtype</code>)           \u2013            <p>Return the dtype for the data.</p> </li> </ul> Source code in <code>ndv/models/_data_wrapper.py</code> <pre><code>def __init__(self, data: ArrayT) -&gt; None:\n    self._data = data\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.axis_map","title":"axis_map  <code>cached</code> <code>property</code>","text":"<pre><code>axis_map: Mapping[Hashable, int]\n</code></pre> <p>Mapping of ALL valid axis keys to normalized, positive integer keys.</p>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.coords","title":"coords  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>coords: Mapping[Hashable, Sequence]\n</code></pre> <p>Return the coordinates for the data.</p>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.data","title":"data  <code>property</code>","text":"<pre><code>data: ArrayT\n</code></pre> <p>Return the data being wrapped.</p>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.dims","title":"dims  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>dims: tuple[Hashable, ...]\n</code></pre> <p>Return the dimension labels for the data.</p>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: dtype\n</code></pre> <p>Return the dtype for the data.</p>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.clear_cache","title":"clear_cache","text":"<pre><code>clear_cache() -&gt; None\n</code></pre> <p>Clear any cached properties.</p> Source code in <code>ndv/models/_data_wrapper.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear any cached properties.\"\"\"\n    if hasattr(self, \"axis_map\"):\n        del self.axis_map\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.guess_channel_axis","title":"guess_channel_axis","text":"<pre><code>guess_channel_axis() -&gt; Hashable | None\n</code></pre> <p>Return the (best guess) axis name for the channel dimension.</p> Source code in <code>ndv/models/_data_wrapper.py</code> <pre><code>def guess_channel_axis(self) -&gt; Hashable | None:\n    \"\"\"Return the (best guess) axis name for the channel dimension.\"\"\"\n    # for arrays with labeled dimensions,\n    # see if any of the dimensions are named \"channel\"\n    sizes = self.sizes()\n    for dimkey, val in sizes.items():\n        if str(dimkey).lower() in self.COMMON_CHANNEL_NAMES:\n            if val &lt;= self.MAX_CHANNELS:\n                return self.normalized_axis_key(dimkey)\n\n    # otherwise use the smallest dimension as the channel axis\n    return min(sizes, key=sizes.get)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.isel","title":"isel  <code>abstractmethod</code>","text":"<pre><code>isel(index: Mapping[int, int | slice]) -&gt; ndarray\n</code></pre> <p>Return a slice of the data as a numpy array.</p> Source code in <code>ndv/models/_data_wrapper.py</code> <pre><code>@abstractmethod\ndef isel(self, index: Mapping[int, int | slice]) -&gt; np.ndarray:\n    \"\"\"Return a slice of the data as a numpy array.\"\"\"\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.normalized_axis_key","title":"normalized_axis_key","text":"<pre><code>normalized_axis_key(axis: Hashable) -&gt; int\n</code></pre> <p>Return positive index for <code>axis</code> (which can be +/- int or str label).</p> Source code in <code>ndv/models/_data_wrapper.py</code> <pre><code>def normalized_axis_key(self, axis: Hashable) -&gt; int:\n    \"\"\"Return positive index for `axis` (which can be +/- int or str label).\"\"\"\n    try:\n        return self.axis_map[axis]\n    except KeyError as e:\n        ndims = len(self.dims)\n        if isinstance(axis, int):\n            raise IndexError(\n                f\"Axis index {axis} out of bounds for data with {ndims} dimensions\"\n            ) from e\n        raise IndexError(f\"Axis label {axis} not found in data dimensions\") from e\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.sizes","title":"sizes","text":"<pre><code>sizes() -&gt; Mapping[Hashable, int]\n</code></pre> <p>Return the sizes of the dimensions.</p> Source code in <code>ndv/models/_data_wrapper.py</code> <pre><code>def sizes(self) -&gt; Mapping[Hashable, int]:\n    \"\"\"Return the sizes of the dimensions.\"\"\"\n    return {dim: len(self.coords[dim]) for dim in self.dims}\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.summary_info","title":"summary_info","text":"<pre><code>summary_info() -&gt; str\n</code></pre> <p>Return info label with information about the data.</p> Source code in <code>ndv/models/_data_wrapper.py</code> <pre><code>def summary_info(self) -&gt; str:\n    \"\"\"Return info label with information about the data.\"\"\"\n    package = getattr(self._data, \"__module__\", \"\").split(\".\")[0]\n    info = f\"{package}.{getattr(type(self._data), '__qualname__', '')}\"\n\n    if sizes := self.sizes():\n        # if all of the dimension keys are just integers, omit them from size_str\n        if all(isinstance(x, int) for x in sizes):\n            size_str = repr(tuple(sizes.values()))\n        # otherwise, include the keys in the size_str\n        else:\n            size_str = \", \".join(f\"{k}:{v}\" for k, v in sizes.items())\n            size_str = f\"({size_str})\"\n        info += f\" {size_str}\"\n    if dtype := getattr(self._data, \"dtype\", \"\"):\n        info += f\", {dtype}\"\n    if nbytes := getattr(self._data, \"nbytes\", 0) / 1e6:\n        info += f\", {nbytes:.2f}MB\"\n    return info\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.DataWrapper.supports","title":"supports  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>supports(obj: Any) -&gt; bool\n</code></pre> <p>Return True if this wrapper can handle the given object.</p> <p>Any exceptions raised by this method will be suppressed, so it is safe to directly import necessary dependencies without a try/except block.</p> Source code in <code>ndv/models/_data_wrapper.py</code> <pre><code>@classmethod\n@abstractmethod\ndef supports(cls, obj: Any) -&gt; bool:\n    \"\"\"Return True if this wrapper can handle the given object.\n\n    Any exceptions raised by this method will be suppressed, so it is safe to\n    directly import necessary dependencies without a try/except block.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/models/#ndv.models.LUTModel","title":"LUTModel","text":"<p>               Bases: <code>NDVModel</code></p> <p>Representation of how to display a channel of an array.</p> <p>Attributes:</p> <ul> <li> <code>visible</code>               (<code>bool</code>)           \u2013            <p>Whether to display this channel. NOTE: This has implications for data retrieval, as we may not want to request channels that are not visible.  See current_index above.</p> </li> <li> <code>cmap</code>               (<code>Colormap</code>)           \u2013            <p>Colormap to use for this channel.</p> </li> <li> <code>clims</code>               (<code>tuple[float, float] | None</code>)           \u2013            <p>Contrast limits for this channel. TODO: What does <code>None</code> imply?  Autoscale?</p> </li> <li> <code>gamma</code>               (<code>float</code>)           \u2013            <p>Gamma correction for this channel. By default, 1.0.</p> </li> <li> <code>autoscale</code>               (<code>bool | tuple[float, float]</code>)           \u2013            <p>Whether/how to autoscale the colormap. If <code>False</code>, then autoscaling is disabled. If <code>True</code> or <code>(0, 1)</code> then autoscale using the min/max of the data. If a tuple, then the first element is the lower quantile and the second element is the upper quantile. If a callable, then it should be a function that takes an array and returns a tuple of (min, max) values to use for scaling.</p> <p>NaN values should be ignored (n.b. nanmax is slower and should only be used if necessary).</p> </li> </ul>"},{"location":"reference/ndv/v1/","title":"ndv.v1","text":""},{"location":"reference/ndv/v1/#ndv.v1","title":"ndv.v1","text":"<p>Here to allow access to the original (legacy) version of NDViewer.</p> <p>Warning</p> <p>This module should not be used for new code.  It will be removed in a future release.</p> <p>Classes:</p> <ul> <li> <code>DataWrapper</code>           \u2013            <p>Interface for wrapping different array-like data types.</p> </li> <li> <code>NDViewer</code>           \u2013            <p>A viewer for ND arrays.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>imshow</code>             \u2013              <p>Display an array or DataWrapper in a new NDViewer window.</p> </li> </ul>"},{"location":"reference/ndv/v1/#ndv.v1.DataWrapper","title":"DataWrapper","text":"<pre><code>DataWrapper(data: ArrayT)\n</code></pre> <p>               Bases: <code>Generic[ArrayT]</code></p> <p>Interface for wrapping different array-like data types.</p> <p><code>DataWrapper.create</code> is a factory method that returns a DataWrapper instance for the given data type. If your datastore type is not supported, you may implement a new DataWrapper subclass to handle your data type.  To do this, import and subclass DataWrapper, and (minimally) implement the supports and isel methods. Ensure that your class is imported before the DataWrapper.create method is called, and it will be automatically detected and used to wrap your data.</p> <p>Methods:</p> <ul> <li> <code>guess_channel_axis</code>             \u2013              <p>Return the (best guess) axis name for the channel dimension.</p> </li> <li> <code>isel</code>             \u2013              <p>Select a slice from a data store using (possibly) named indices.</p> </li> <li> <code>isel_async</code>             \u2013              <p>Asynchronous version of isel.</p> </li> <li> <code>sizes</code>             \u2013              <p>Return a mapping of {dimkey: size} for the data.</p> </li> <li> <code>summary_info</code>             \u2013              <p>Return info label with information about the data.</p> </li> <li> <code>supports</code>             \u2013              <p>Return True if this wrapper can handle the given object.</p> </li> </ul> Source code in <code>ndv/v1/_old_data_wrapper.py</code> <pre><code>def __init__(self, data: ArrayT) -&gt; None:\n    self._data = data\n</code></pre>"},{"location":"reference/ndv/v1/#ndv.v1.DataWrapper.guess_channel_axis","title":"guess_channel_axis","text":"<pre><code>guess_channel_axis() -&gt; Any | None\n</code></pre> <p>Return the (best guess) axis name for the channel dimension.</p> Source code in <code>ndv/v1/_old_data_wrapper.py</code> <pre><code>def guess_channel_axis(self) -&gt; Any | None:\n    \"\"\"Return the (best guess) axis name for the channel dimension.\"\"\"\n    # for arrays with labeled dimensions,\n    # see if any of the dimensions are named \"channel\"\n    for dimkey, val in self.sizes().items():\n        if str(dimkey).lower() in self.COMMON_CHANNEL_NAMES:\n            if val &lt;= self.MAX_CHANNELS:\n                return dimkey\n\n    # for shaped arrays, use the smallest dimension as the channel axis\n    shape = getattr(self._data, \"shape\", None)\n    if isinstance(shape, Sequence):\n        with suppress(ValueError):\n            smallest_dim = min(shape)\n            if smallest_dim &lt;= self.MAX_CHANNELS:\n                return shape.index(smallest_dim)\n    return None\n</code></pre>"},{"location":"reference/ndv/v1/#ndv.v1.DataWrapper.isel","title":"isel  <code>abstractmethod</code>","text":"<pre><code>isel(indexers: Indices) -&gt; ndarray\n</code></pre> <p>Select a slice from a data store using (possibly) named indices.</p> <p>This follows the xarray-style indexing, where indexers is a mapping of dimension names to indices or slices.  Subclasses should implement this method to return a numpy array.</p> Source code in <code>ndv/v1/_old_data_wrapper.py</code> <pre><code>@abstractmethod\ndef isel(self, indexers: Indices) -&gt; np.ndarray:\n    \"\"\"Select a slice from a data store using (possibly) named indices.\n\n    This follows the xarray-style indexing, where indexers is a mapping of\n    dimension names to indices or slices.  Subclasses should implement this\n    method to return a numpy array.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/ndv/v1/#ndv.v1.DataWrapper.isel_async","title":"isel_async","text":"<pre><code>isel_async(indexers: list[Indices]) -&gt; Future[Iterable[tuple[Indices, ndarray]]]\n</code></pre> <p>Asynchronous version of isel.</p> Source code in <code>ndv/v1/_old_data_wrapper.py</code> <pre><code>def isel_async(\n    self, indexers: list[Indices]\n) -&gt; Future[Iterable[tuple[Indices, np.ndarray]]]:\n    \"\"\"Asynchronous version of isel.\"\"\"\n    return _EXECUTOR.submit(lambda: [(idx, self.isel(idx)) for idx in indexers])\n</code></pre>"},{"location":"reference/ndv/v1/#ndv.v1.DataWrapper.sizes","title":"sizes","text":"<pre><code>sizes() -&gt; Sizes\n</code></pre> <p>Return a mapping of {dimkey: size} for the data.</p> <p>The default implementation uses the shape attribute of the data, and tries to find dimension names in the <code>dims</code>, <code>names</code>, or <code>labels</code> attributes. (<code>dims</code> is used by xarray, <code>names</code> is used by torch, etc...). If no labels are found, the dimensions are just named by their integer index.</p> Source code in <code>ndv/v1/_old_data_wrapper.py</code> <pre><code>def sizes(self) -&gt; Sizes:\n    \"\"\"Return a mapping of {dimkey: size} for the data.\n\n    The default implementation uses the shape attribute of the data, and\n    tries to find dimension names in the `dims`, `names`, or `labels` attributes.\n    (`dims` is used by xarray, `names` is used by torch, etc...). If no labels\n    are found, the dimensions are just named by their integer index.\n    \"\"\"\n    shape = getattr(self._data, \"shape\", None)\n    if not isinstance(shape, Sequence) or not all(\n        isinstance(x, int) for x in shape\n    ):\n        raise NotImplementedError(f\"Cannot determine sizes for {type(self._data)}\")\n    dims = range(len(shape))\n    return {dim: int(size) for dim, size in zip(dims, shape)}\n</code></pre>"},{"location":"reference/ndv/v1/#ndv.v1.DataWrapper.summary_info","title":"summary_info","text":"<pre><code>summary_info() -&gt; str\n</code></pre> <p>Return info label with information about the data.</p> Source code in <code>ndv/v1/_old_data_wrapper.py</code> <pre><code>def summary_info(self) -&gt; str:\n    \"\"\"Return info label with information about the data.\"\"\"\n    package = getattr(self._data, \"__module__\", \"\").split(\".\")[0]\n    info = f\"{package}.{getattr(type(self._data), '__qualname__', '')}\"\n\n    if sizes := self.sizes():\n        # if all of the dimension keys are just integers, omit them from size_str\n        if all(isinstance(x, int) for x in sizes):\n            size_str = repr(tuple(sizes.values()))\n        # otherwise, include the keys in the size_str\n        else:\n            size_str = \", \".join(f\"{k}:{v}\" for k, v in sizes.items())\n            size_str = f\"({size_str})\"\n        info += f\" {size_str}\"\n    if dtype := getattr(self._data, \"dtype\", \"\"):\n        info += f\", {dtype}\"\n    if nbytes := getattr(self._data, \"nbytes\", 0) / 1e6:\n        info += f\", {nbytes:.2f}MB\"\n    return info\n</code></pre>"},{"location":"reference/ndv/v1/#ndv.v1.DataWrapper.supports","title":"supports  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>supports(obj: Any) -&gt; bool\n</code></pre> <p>Return True if this wrapper can handle the given object.</p> <p>Any exceptions raised by this method will be suppressed, so it is safe to directly import necessary dependencies without a try/except block.</p> Source code in <code>ndv/v1/_old_data_wrapper.py</code> <pre><code>@classmethod\n@abstractmethod\ndef supports(cls, obj: Any) -&gt; bool:\n    \"\"\"Return True if this wrapper can handle the given object.\n\n    Any exceptions raised by this method will be suppressed, so it is safe to\n    directly import necessary dependencies without a try/except block.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/ndv/v1/#ndv.v1.NDViewer","title":"NDViewer","text":"<pre><code>NDViewer(data: DataWrapper | Any | None = None, *, colormaps: Iterable[ColorStopsLike] | None = None, parent: QWidget | None = None, channel_axis: DimKey | None = None, channel_mode: ChannelMode | str = MONO)\n</code></pre> <p>               Bases: <code>QWidget</code></p> <p>A viewer for ND arrays.</p> <p>This widget displays a single slice from an ND array (or a composite of slices in different colormaps).  The widget provides sliders to select the slice to display, and buttons to control the display mode of the channels.</p> <p>An important concept in this widget is the \"index\".  The index is a mapping of dimensions to integers or slices that define the slice of the data to display.  For example, a numpy slice of <code>[0, 1, 5:10]</code> would be represented as <code>{0: 0, 1: 1, 2: slice(5, 10)}</code>, but dimensions can also be named, e.g. <code>{'t': 0, 'c': 1, 'z': slice(5, 10)}</code>. The index is used to select the data from the datastore, and to determine the position of the sliders.</p> <p>The flow of data is as follows:</p> <ul> <li>The user sets the data using the <code>set_data</code> method. This will set the number   and range of the sliders to the shape of the data, and display the first slice.</li> <li>The user can then use the sliders to select the slice to display. The current   slice is defined as a <code>Mapping</code> of <code>{dim -&gt; int|slice}</code> and can be retrieved   with the <code>_dims_sliders.value()</code> method.  To programmatically set the current   position, use the <code>setIndex</code> method. This will set the values of the sliders,   which in turn will trigger the display of the new slice via the   <code>_update_data_for_index</code> method.</li> <li><code>_update_data_for_index</code> is an asynchronous method that retrieves the data for   the given index from the datastore (using <code>_isel</code>) and queues the   <code>_on_data_slice_ready</code> method to be called when the data is ready. The logic   for extracting data from the datastore is defined in <code>_data_wrapper.py</code>, which   handles idiosyncrasies of different datastores (e.g. xarray, tensorstore, etc).</li> <li><code>_on_data_slice_ready</code> is called when the data is ready, and updates the image.   Note that if the slice is multidimensional, the data will be reduced to 2D using   max intensity projection (and double-clicking on any given dimension slider will   turn it into a range slider allowing a projection to be made over that dimension).</li> <li>The image is displayed on the canvas, which is an object that implements the   <code>PCanvas</code> protocol (mostly, it has an <code>add_image</code> method that returns a handle   to the added image that can be used to update the data and display). This   small abstraction allows for various backends to be used (e.g. vispy, pygfx, etc).</li> </ul> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> <li> </li> </ul> <p>Methods:</p> <ul> <li> <code>eventFilter</code>             \u2013              <p>Event filter installed on the canvas to handle mouse events.</p> </li> <li> <code>refresh</code>             \u2013              <p>Refresh the canvas.</p> </li> <li> <code>set_channel_mode</code>             \u2013              <p>Set the mode for displaying the channels.</p> </li> <li> <code>set_current_index</code>             \u2013              <p>Set the index of the displayed image.</p> </li> <li> <code>set_data</code>             \u2013              <p>Set the datastore, and, optionally, the sizes of the data.</p> </li> <li> <code>set_ndim</code>             \u2013              <p>Set the number of dimensions to display.</p> </li> <li> <code>set_roi</code>             \u2013              <p>Set the properties of the ROI overlaid on the displayed data.</p> </li> <li> <code>set_visualized_dims</code>             \u2013              <p>Set the dimensions that will be visualized.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>data</code>               (<code>Any</code>)           \u2013            <p>Return the data backing the view.</p> </li> <li> <code>data_wrapper</code>               (<code>DataWrapper | None</code>)           \u2013            <p>Return the DataWrapper object around the datastore.</p> </li> <li> <code>dims_sliders</code>               (<code>DimsSliders</code>)           \u2013            <p>Return the DimsSliders widget.</p> </li> </ul> Source code in <code>ndv/v1/_old_viewer.py</code> <pre><code>def __init__(\n    self,\n    data: DataWrapper | Any | None = None,\n    *,\n    colormaps: Iterable[cmap._colormap.ColorStopsLike] | None = None,\n    parent: QWidget | None = None,\n    channel_axis: DimKey | None = None,\n    channel_mode: ChannelMode | str = ChannelMode.MONO,\n):\n    super().__init__(parent=parent)\n\n    # ATTRIBUTES ----------------------------------------------------\n    self._data_wrapper: DataWrapper | None = None\n\n    # mapping of key to a list of objects that control image nodes in the canvas\n    self._img_handles: defaultdict[ImgKey, list[ImageHandle]] = defaultdict(list)\n    # mapping of same keys to the LutControl objects control image display props\n    self._lut_ctrls: dict[ImgKey, LutControl] = {}\n    self._lut_ctrl_state: dict[ImgKey, dict] = {}\n    # the set of dimensions we are currently visualizing (e.g. XY)\n    # this is used to control which dimensions have sliders and the behavior\n    # of isel when selecting data from the datastore\n    self._visualized_dims: set[DimKey] = set()\n    # the axis that represents the channels in the data\n    self._channel_axis = channel_axis\n    self._channel_mode: ChannelMode = None  # type: ignore # set in set_channel_mode\n    # colormaps that will be cycled through when displaying composite images\n    if colormaps is not None:\n        self._cmaps = [cmap.Colormap(c) for c in colormaps]\n    else:\n        self._cmaps = DEFAULT_COLORMAPS\n    self._cmap_cycle = cycle(self._cmaps)\n    # the last future that was created by _update_data_for_index\n    self._last_future: Future | None = None\n\n    # number of dimensions to display\n    self._ndims: Literal[2, 3] = 2\n\n    # Canvas selection\n    self._selection: CanvasElement | None = None\n    # ROI\n    self._roi: RoiHandle | None = None\n\n    # WIDGETS ----------------------------------------------------\n\n    # the button that controls the display mode of the channels\n    self._channel_mode_btn = ChannelModeButton(self)\n    self._channel_mode_btn.clicked.connect(self.set_channel_mode)\n    # button to reset the zoom of the canvas\n    self._set_range_btn = QPushButton(\n        QIconifyIcon(\"fluent:full-screen-maximize-24-filled\"), \"\", self\n    )\n    self._set_range_btn.clicked.connect(self._on_set_range_clicked)\n    # button to draw ROIs\n    self._add_roi_btn = ROIButton()\n    self._add_roi_btn.toggled.connect(self._on_add_roi_clicked)\n\n    # button to change number of displayed dimensions\n    self._ndims_btn = DimToggleButton(self)\n    self._ndims_btn.clicked.connect(self._toggle_3d)\n\n    # place to display dataset summary\n    self._data_info_label = QElidingLabel(\"\", parent=self)\n    self._progress_spinner = QSpinner(self)\n\n    # place to display arbitrary text\n    self._hover_info_label = QLabel(\"\", self)\n    # the canvas that displays the images\n    self._canvas: ArrayCanvas = get_array_canvas_class()()\n    self._canvas.set_ndim(self._ndims)\n    self._qcanvas = self._canvas.frontend_widget()\n\n    # Install an event filter so we can intercept mouse/key events\n    self._qcanvas.installEventFilter(self)\n\n    # the sliders that control the index of the displayed image\n    self._dims_sliders = DimsSliders(self)\n    self._dims_sliders.valueChanged.connect(\n        qthrottled(self._update_data_for_index, 20, leading=True)\n    )\n\n    self._lut_drop = QCollapsible(\"LUTs\", self)\n    self._lut_drop.setCollapsedIcon(QIconifyIcon(\"bi:chevron-down\", color=MID_GRAY))\n    self._lut_drop.setExpandedIcon(QIconifyIcon(\"bi:chevron-up\", color=MID_GRAY))\n    lut_layout = cast(\"QVBoxLayout\", self._lut_drop.layout())\n    lut_layout.setContentsMargins(0, 1, 0, 1)\n    lut_layout.setSpacing(0)\n    if (\n        hasattr(self._lut_drop, \"_content\")\n        and (layout := self._lut_drop._content.layout()) is not None\n    ):\n        layout.setContentsMargins(0, 0, 0, 0)\n        layout.setSpacing(0)\n\n    # LAYOUT -----------------------------------------------------\n\n    self._btns = btns = QHBoxLayout()\n    btns.setContentsMargins(0, 0, 0, 0)\n    btns.setSpacing(0)\n    btns.addStretch()\n    btns.addWidget(self._channel_mode_btn)\n    btns.addWidget(self._ndims_btn)\n    btns.addWidget(self._set_range_btn)\n    btns.addWidget(self._add_roi_btn)\n\n    info_widget = QWidget()\n    info = QHBoxLayout(info_widget)\n    info.setContentsMargins(0, 0, 0, 2)\n    info.setSpacing(0)\n    info.addWidget(self._data_info_label)\n    info.addWidget(self._progress_spinner)\n    info_widget.setFixedHeight(16)\n\n    layout = QVBoxLayout(self)\n    layout.setSpacing(2)\n    layout.setContentsMargins(6, 6, 6, 6)\n    layout.addWidget(info_widget)\n    layout.addWidget(self._qcanvas, 1)\n    layout.addWidget(self._hover_info_label)\n    layout.addWidget(self._dims_sliders)\n    layout.addWidget(self._lut_drop)\n    layout.addLayout(btns)\n\n    # SETUP ------------------------------------------------------\n\n    self.set_channel_mode(channel_mode)\n    self.set_data(data)\n</code></pre>"},{"location":"reference/ndv/v1/#ndv.v1.NDViewer(data)","title":"<code>data</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The data to display.  This can be any duck-like ND array, including numpy, dask, xarray, jax, tensorstore, zarr, etc.  You can add support for new datastores by subclassing <code>DataWrapper</code> and implementing the required methods.  See <code>DataWrapper</code> for more information.</p>"},{"location":"reference/ndv/v1/#ndv.v1.NDViewer(parent)","title":"<code>parent</code>","text":"(<code>QWidget</code>, default:                   <code>None</code> )           \u2013            <p>The parent widget of this widget.</p>"},{"location":"reference/ndv/v1/#ndv.v1.NDViewer(channel_axis)","title":"<code>channel_axis</code>","text":"(<code>Hashable</code>, default:                   <code>None</code> )           \u2013            <p>The axis that represents the channels in the data.  If not provided, this will be guessed from the data.</p>"},{"location":"reference/ndv/v1/#ndv.v1.NDViewer(channel_mode)","title":"<code>channel_mode</code>","text":"(<code>ChannelMode</code>, default:                   <code>MONO</code> )           \u2013            <p>The initial mode for displaying the channels. If not provided, this will be set to ChannelMode.MONO.</p>"},{"location":"reference/ndv/v1/#ndv.v1.NDViewer.data","title":"data  <code>property</code> <code>writable</code>","text":"<pre><code>data: Any\n</code></pre> <p>Return the data backing the view.</p>"},{"location":"reference/ndv/v1/#ndv.v1.NDViewer.data_wrapper","title":"data_wrapper  <code>property</code>","text":"<pre><code>data_wrapper: DataWrapper | None\n</code></pre> <p>Return the DataWrapper object around the datastore.</p>"},{"location":"reference/ndv/v1/#ndv.v1.NDViewer.dims_sliders","title":"dims_sliders  <code>property</code>","text":"<pre><code>dims_sliders: DimsSliders\n</code></pre> <p>Return the DimsSliders widget.</p>"},{"location":"reference/ndv/v1/#ndv.v1.NDViewer.eventFilter","title":"eventFilter","text":"<pre><code>eventFilter(obj: QObject | None, event: QEvent | None) -&gt; bool\n</code></pre> <p>Event filter installed on the canvas to handle mouse events.</p> Source code in <code>ndv/v1/_old_viewer.py</code> <pre><code>def eventFilter(self, obj: QObject | None, event: QEvent | None) -&gt; bool:\n    \"\"\"Event filter installed on the canvas to handle mouse events.\"\"\"\n    if event is None:\n        return False  # pragma: no cover\n\n    # here is where we get a chance to intercept mouse events before passing them\n    # to the canvas. Return `True` to prevent the event from being passed to\n    # the backend widget.\n    intercept = False\n    # use children in case backend has a subwidget stealing events.\n    if obj is self._qcanvas or obj in (self._qcanvas.children()):\n        if isinstance(event, QMouseEvent):\n            intercept |= self._canvas_mouse_event(event)\n        if event.type() == QEvent.Type.KeyPress:\n            self.keyPressEvent(cast(\"QKeyEvent\", event))\n    return intercept\n</code></pre>"},{"location":"reference/ndv/v1/#ndv.v1.NDViewer.refresh","title":"refresh","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Refresh the canvas.</p> Source code in <code>ndv/v1/_old_viewer.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refresh the canvas.\"\"\"\n    self._clear_images()\n    self._update_data_for_index(self._dims_sliders.value())\n</code></pre>"},{"location":"reference/ndv/v1/#ndv.v1.NDViewer.set_channel_mode","title":"set_channel_mode","text":"<pre><code>set_channel_mode(mode: ChannelMode | str | None = None) -&gt; None\n</code></pre> <p>Set the mode for displaying the channels.</p> <p>In \"composite\" mode, the channels are displayed as a composite image, using self._channel_axis as the channel axis. In \"grayscale\" mode, each channel is displayed separately. (If mode is None, the current value of the channel_mode_picker button is used)</p> <p>Parameters:</p> Source code in <code>ndv/v1/_old_viewer.py</code> <pre><code>def set_channel_mode(self, mode: ChannelMode | str | None = None) -&gt; None:\n    \"\"\"Set the mode for displaying the channels.\n\n    In \"composite\" mode, the channels are displayed as a composite image, using\n    self._channel_axis as the channel axis. In \"grayscale\" mode, each channel is\n    displayed separately. (If mode is None, the current value of the\n    channel_mode_picker button is used)\n\n    Parameters\n    ----------\n    mode : ChannelMode | str | None\n        The mode to set, must be one of 'composite' or 'mono'.\n    \"\"\"\n    # bool may happen when called from the button clicked signal\n    if mode is None or isinstance(mode, bool):\n        mode = self._channel_mode_btn.mode()\n    else:\n        mode = ChannelMode(mode)\n        self._channel_mode_btn.setMode(mode)\n    if mode == self._channel_mode:\n        return\n\n    self._channel_mode = mode\n    self._cmap_cycle = cycle(self._cmaps)  # reset the colormap cycle\n    if self._channel_axis is not None:\n        # set the visibility of the channel slider\n        self._dims_sliders.set_dimension_visible(\n            self._channel_axis, mode != ChannelMode.COMPOSITE\n        )\n\n    self.refresh()\n</code></pre>"},{"location":"reference/ndv/v1/#ndv.v1.NDViewer.set_channel_mode(mode)","title":"<code>mode</code>","text":"(<code>ChannelMode | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The mode to set, must be one of 'composite' or 'mono'.</p>"},{"location":"reference/ndv/v1/#ndv.v1.NDViewer.set_current_index","title":"set_current_index","text":"<pre><code>set_current_index(index: Indices | None = None) -&gt; None\n</code></pre> <p>Set the index of the displayed image.</p> <p><code>index</code> is a mapping of dimensions to integers or slices that define the slice of the data to display.  For example, a numpy slice of <code>[0, 1, 5:10]</code> would be represented as <code>{0: 0, 1: 1, 2: slice(5, 10)}</code>, but dimensions can also be named, e.g. <code>{'t': 0, 'c': 1, 'z': slice(5, 10)}</code> if the data has named dimensions.</p> <p>Note, calling <code>.set_current_index()</code> with no arguments will force the widget to redraw the current slice.</p> Source code in <code>ndv/v1/_old_viewer.py</code> <pre><code>def set_current_index(self, index: Indices | None = None) -&gt; None:\n    \"\"\"Set the index of the displayed image.\n\n    `index` is a mapping of dimensions to integers or slices that define the slice\n    of the data to display.  For example, a numpy slice of `[0, 1, 5:10]` would be\n    represented as `{0: 0, 1: 1, 2: slice(5, 10)}`, but dimensions can also be\n    named, e.g. `{'t': 0, 'c': 1, 'z': slice(5, 10)}` if the data has named\n    dimensions.\n\n    Note, calling `.set_current_index()` with no arguments will force the widget\n    to redraw the current slice.\n    \"\"\"\n    self._dims_sliders.setValue(index or {})\n</code></pre>"},{"location":"reference/ndv/v1/#ndv.v1.NDViewer.set_data","title":"set_data","text":"<pre><code>set_data(data: DataWrapper | Any, *, initial_index: Indices | None = None) -&gt; None\n</code></pre> <p>Set the datastore, and, optionally, the sizes of the data.</p> Properties <p>data : DataWrapper | Any     The data to display.  This can be any duck-like ND array, including numpy,     dask, xarray, jax, tensorstore, zarr, etc.  You can add support for new     datastores by subclassing <code>DataWrapper</code> and implementing the required     methods. If a <code>DataWrapper</code> instance is passed, it is used directly.     See <code>DataWrapper</code> for more information. initial_index : Indices | None     The initial index to display.  This is a mapping of dimensions to integers     or slices that define the slice of the data to display.  If not provided,     the initial index will be set to the middle of the data.</p> Source code in <code>ndv/v1/_old_viewer.py</code> <pre><code>def set_data(\n    self, data: DataWrapper | Any, *, initial_index: Indices | None = None\n) -&gt; None:\n    \"\"\"Set the datastore, and, optionally, the sizes of the data.\n\n    Properties\n    ----------\n    data : DataWrapper | Any\n        The data to display.  This can be any duck-like ND array, including numpy,\n        dask, xarray, jax, tensorstore, zarr, etc.  You can add support for new\n        datastores by subclassing `DataWrapper` and implementing the required\n        methods. If a `DataWrapper` instance is passed, it is used directly.\n        See `DataWrapper` for more information.\n    initial_index : Indices | None\n        The initial index to display.  This is a mapping of dimensions to integers\n        or slices that define the slice of the data to display.  If not provided,\n        the initial index will be set to the middle of the data.\n    \"\"\"\n    # clear current data\n    if data is None:\n        self._data_wrapper = None\n        self._clear_images()\n        self._dims_sliders.clear()\n        self._data_info_label.setText(\"\")\n        return\n\n    # store the data\n    self._data_wrapper = DataWrapper.create(data)\n\n    # set channel axis\n    self._channel_axis = self._data_wrapper.guess_channel_axis()\n\n    # update the dimensions we are visualizing\n    sizes = self._data_wrapper.sizes()\n    visualized_dims = list(sizes)[-self._ndims :]\n    self.set_visualized_dims(visualized_dims)\n\n    # update the range of all the sliders to match the sizes we set above\n    with signals_blocked(self._dims_sliders):\n        self._update_slider_ranges()\n\n    # redraw\n    if initial_index is None:\n        idx = self._dims_sliders.value() or {\n            k: int(v // 2) for k, v in sizes.items()\n        }\n    else:\n        if not isinstance(initial_index, dict):  # pragma: no cover\n            raise TypeError(\"initial_index must be a dict\")\n        idx = initial_index\n    with signals_blocked(self._dims_sliders):\n        self.set_current_index(idx)\n    # update the data info label\n    self._data_info_label.setText(self._data_wrapper.summary_info())\n    self.refresh()\n</code></pre>"},{"location":"reference/ndv/v1/#ndv.v1.NDViewer.set_ndim","title":"set_ndim","text":"<pre><code>set_ndim(ndim: Literal[2, 3]) -&gt; None\n</code></pre> <p>Set the number of dimensions to display.</p> Source code in <code>ndv/v1/_old_viewer.py</code> <pre><code>def set_ndim(self, ndim: Literal[2, 3]) -&gt; None:\n    \"\"\"Set the number of dimensions to display.\"\"\"\n    if ndim not in (2, 3):\n        raise ValueError(\"ndim must be 2 or 3\")\n\n    self._ndims = ndim\n    self._canvas.set_ndim(ndim)\n\n    if self._data_wrapper is None:\n        return\n\n    # set the visibility of the last non-channel dimension\n    sizes = list(self._data_wrapper.sizes())\n    if self._channel_axis is not None:\n        sizes = [x for x in sizes if x != self._channel_axis]\n    if len(sizes) &gt;= 3:\n        dim3 = sizes[-3]\n        self._dims_sliders.set_dimension_visible(dim3, True if ndim == 2 else False)\n\n    # clear image handles and redraw\n    self.refresh()\n</code></pre>"},{"location":"reference/ndv/v1/#ndv.v1.NDViewer.set_roi","title":"set_roi","text":"<pre><code>set_roi(vertices: list[tuple[float, float]] | None = None, color: Any = None, border_color: Any = None) -&gt; None\n</code></pre> <p>Set the properties of the ROI overlaid on the displayed data.</p> Properties <p>vertices : list[tuple[float, float]] | None     The vertices of the ROI. color : str, tuple, list, array, Color, or int     The fill color.  Can be any \"ColorLike\". border_color : str, tuple, list, array, Color, or int     The border color.  Can be any \"ColorLike\".</p> Source code in <code>ndv/v1/_old_viewer.py</code> <pre><code>def set_roi(\n    self,\n    vertices: list[tuple[float, float]] | None = None,\n    color: Any = None,\n    border_color: Any = None,\n) -&gt; None:\n    \"\"\"Set the properties of the ROI overlaid on the displayed data.\n\n    Properties\n    ----------\n    vertices : list[tuple[float, float]] | None\n        The vertices of the ROI.\n    color : str, tuple, list, array, Color, or int\n        The fill color.  Can be any \"ColorLike\".\n    border_color : str, tuple, list, array, Color, or int\n        The border color.  Can be any \"ColorLike\".\n    \"\"\"\n    # Remove the old ROI\n    if self._roi:\n        self._roi.remove()\n    color = cmap.Color(color) if color is not None else None\n    border_color = cmap.Color(border_color) if border_color is not None else None\n    self._roi = self._canvas.add_roi(\n        vertices=vertices, color=color, border_color=border_color\n    )\n</code></pre>"},{"location":"reference/ndv/v1/#ndv.v1.NDViewer.set_visualized_dims","title":"set_visualized_dims","text":"<pre><code>set_visualized_dims(dims: Iterable[DimKey]) -&gt; None\n</code></pre> <p>Set the dimensions that will be visualized.</p> <p>This dims will NOT have sliders associated with them.</p> Source code in <code>ndv/v1/_old_viewer.py</code> <pre><code>def set_visualized_dims(self, dims: Iterable[DimKey]) -&gt; None:\n    \"\"\"Set the dimensions that will be visualized.\n\n    This dims will NOT have sliders associated with them.\n    \"\"\"\n    self._visualized_dims = set(dims)\n    for d in self._dims_sliders._sliders:\n        self._dims_sliders.set_dimension_visible(d, d not in self._visualized_dims)\n    for d in self._visualized_dims:\n        self._dims_sliders.set_dimension_visible(d, False)\n</code></pre>"},{"location":"reference/ndv/v1/#ndv.v1.imshow","title":"imshow","text":"<pre><code>imshow(data: Any | DataWrapper, cmap: Any | None = None, *, channel_mode: Literal['mono', 'composite', 'auto'] = 'auto') -&gt; NDViewer\n</code></pre> <p>Display an array or DataWrapper in a new NDViewer window.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>NDViewer</code>           \u2013            <p>The viewer window.</p> </li> </ul> Source code in <code>ndv/v1/_util.py</code> <pre><code>def imshow(\n    data: Any | DataWrapper,\n    cmap: Any | None = None,\n    *,\n    channel_mode: Literal[\"mono\", \"composite\", \"auto\"] = \"auto\",\n) -&gt; NDViewer:\n    \"\"\"Display an array or DataWrapper in a new NDViewer window.\n\n    Parameters\n    ----------\n    data : Any | DataWrapper\n        The data to be displayed. If not a DataWrapper, it will be wrapped in one.\n    cmap : Any | None, optional\n        The colormap(s) to use for displaying the data.\n    channel_mode : Literal['mono', 'composite'], optional\n        The initial mode for displaying the channels. By default \"mono\" will be\n        used unless a cmap is provided, in which case \"composite\" will be used.\n\n    Returns\n    -------\n    NDViewer\n        The viewer window.\n    \"\"\"\n    from . import NDViewer\n\n    app, should_exec = _get_app()\n    if cmap is not None:\n        channel_mode = \"composite\"\n        if not isinstance(cmap, (list, tuple)):\n            cmap = [cmap]\n    elif channel_mode == \"auto\":\n        channel_mode = \"mono\"\n    viewer = NDViewer(data, colormaps=cmap, channel_mode=channel_mode)\n    viewer.show()\n    viewer.raise_()\n    if should_exec:\n        app.exec()\n    return viewer\n</code></pre>"},{"location":"reference/ndv/v1/#ndv.v1.imshow(data)","title":"<code>data</code>","text":"(<code>Any | DataWrapper</code>)           \u2013            <p>The data to be displayed. If not a DataWrapper, it will be wrapped in one.</p>"},{"location":"reference/ndv/v1/#ndv.v1.imshow(cmap)","title":"<code>cmap</code>","text":"(<code>Any | None</code>, default:                   <code>None</code> )           \u2013            <p>The colormap(s) to use for displaying the data.</p>"},{"location":"reference/ndv/v1/#ndv.v1.imshow(channel_mode)","title":"<code>channel_mode</code>","text":"(<code>Literal['mono', 'composite']</code>, default:                   <code>'auto'</code> )           \u2013            <p>The initial mode for displaying the channels. By default \"mono\" will be used unless a cmap is provided, in which case \"composite\" will be used.</p>"},{"location":"reference/ndv/views/","title":"ndv.views","text":""},{"location":"reference/ndv/views/#ndv.views","title":"ndv.views","text":"<p>Wrappers around GUI &amp; graphics frameworks.</p> <p>Most stuff in this module is not intended for public use, but <code>ndv.views.bases</code> shows the protocol that GUI &amp; graphics classes should implement.</p> <p>Modules:</p> <ul> <li> <code>bases</code>           \u2013            <p>Abstract base classes for views and viewable objects.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>CanvasBackend</code>           \u2013            <p>Enum of available canvas backends.</p> </li> <li> <code>GuiFrontend</code>           \u2013            <p>Enum of available GUI frontends.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_array_canvas_class</code>             \u2013              <p>Return <code>ArrayCanvas</code> class for current canvas backend.</p> </li> <li> <code>get_array_view_class</code>             \u2013              <p>Return <code>ArrayView</code> class for current GUI frontend.</p> </li> <li> <code>get_histogram_canvas_class</code>             \u2013              <p>Return <code>HistogramCanvas</code> class for current canvas backend.</p> </li> <li> <code>gui_frontend</code>             \u2013              <p>Return the active <code>GuiFrontend</code>.</p> </li> <li> <code>run_app</code>             \u2013              <p>Start the GUI application event loop.</p> </li> </ul>"},{"location":"reference/ndv/views/#ndv.views.CanvasBackend","title":"CanvasBackend","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum of available canvas backends.</p> <p>Attributes:</p> <ul> <li> <code>VISPY</code>               (<code>str</code>)           \u2013            <p>Vispy</p> </li> <li> <code>PYGFX</code>               (<code>str</code>)           \u2013            <p>Pygfx</p> </li> </ul>"},{"location":"reference/ndv/views/#ndv.views.GuiFrontend","title":"GuiFrontend","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum of available GUI frontends.</p> <p>Attributes:</p> <ul> <li> <code>QT</code>               (<code>str</code>)           \u2013            <p>PyQt5/PySide2/PyQt6/PySide6</p> </li> <li> <code>JUPYTER</code>               (<code>str</code>)           \u2013            <p>Jupyter notebook/lab</p> </li> <li> <code>WX</code>               (<code>str</code>)           \u2013            <p>wxPython</p> </li> </ul>"},{"location":"reference/ndv/views/#ndv.views.get_array_canvas_class","title":"get_array_canvas_class","text":"<pre><code>get_array_canvas_class(backend: str | None = None) -&gt; type[ArrayCanvas]\n</code></pre> <p>Return <code>ArrayCanvas</code> class for current canvas backend.</p> Source code in <code>ndv/views/_app.py</code> <pre><code>def get_array_canvas_class(backend: str | None = None) -&gt; type[ArrayCanvas]:\n    \"\"\"Return [`ArrayCanvas`][ndv.views.bases.ArrayCanvas] class for current canvas backend.\"\"\"  # noqa: E501\n    _backend = canvas_backend(backend)\n    if _backend not in CANVAS_PROVIDERS:  # pragma: no cover\n        raise NotImplementedError(f\"No canvas backend found for {_backend}\")\n    return CANVAS_PROVIDERS[_backend].array_canvas_class()\n</code></pre>"},{"location":"reference/ndv/views/#ndv.views.get_array_view_class","title":"get_array_view_class","text":"<pre><code>get_array_view_class() -&gt; type[ArrayView]\n</code></pre> <p>Return <code>ArrayView</code> class for current GUI frontend.</p> Source code in <code>ndv/views/_app.py</code> <pre><code>def get_array_view_class() -&gt; type[ArrayView]:\n    \"\"\"Return [`ArrayView`][ndv.views.bases.ArrayView] class for current GUI frontend.\"\"\"  # noqa: E501\n    if (frontend := gui_frontend()) not in GUI_PROVIDERS:  # pragma: no cover\n        raise NotImplementedError(f\"No GUI frontend found for {frontend}\")\n    return GUI_PROVIDERS[frontend].array_view_class()\n</code></pre>"},{"location":"reference/ndv/views/#ndv.views.get_histogram_canvas_class","title":"get_histogram_canvas_class","text":"<pre><code>get_histogram_canvas_class(backend: str | None = None) -&gt; type[HistogramCanvas]\n</code></pre> <p>Return <code>HistogramCanvas</code> class for current canvas backend.</p> Source code in <code>ndv/views/_app.py</code> <pre><code>def get_histogram_canvas_class(backend: str | None = None) -&gt; type[HistogramCanvas]:\n    \"\"\"Return [`HistogramCanvas`][ndv.views.bases.HistogramCanvas] class for current canvas backend.\"\"\"  # noqa: E501\n    _backend = canvas_backend(backend)\n    if _backend not in CANVAS_PROVIDERS:  # pragma: no cover\n        raise NotImplementedError(f\"No canvas backend found for {_backend}\")\n    return CANVAS_PROVIDERS[_backend].histogram_canvas_class()\n</code></pre>"},{"location":"reference/ndv/views/#ndv.views.gui_frontend","title":"gui_frontend  <code>cached</code>","text":"<pre><code>gui_frontend() -&gt; GuiFrontend\n</code></pre> <p>Return the active <code>GuiFrontend</code>.</p> <p>This is determined first by the <code>NDV_GUI_FRONTEND</code> environment variable, after which known GUI providers are tried in order until one is found that is either already running, or available.</p> Source code in <code>ndv/views/_app.py</code> <pre><code>@cache  # not allowed to change\ndef gui_frontend() -&gt; GuiFrontend:\n    \"\"\"Return the active [`GuiFrontend`][ndv.views.GuiFrontend].\n\n    This is determined first by the `NDV_GUI_FRONTEND` environment variable, after which\n    known GUI providers are tried in order until one is found that is either already\n    running, or available.\n    \"\"\"\n    requested = os.getenv(GUI_ENV_VAR, \"\").lower()\n    valid = {x.value for x in GuiFrontend}\n    if requested:\n        if requested not in valid:\n            raise ValueError(\n                f\"Invalid GUI frontend: {requested!r}. Valid options: {valid}\"\n            )\n        key = GuiFrontend(requested)\n        # ensure the app is created for explicitly requested frontends\n        provider = GUI_PROVIDERS[key]\n        if not provider.is_running():\n            provider.create_app()\n        return key\n\n    for key, provider in GUI_PROVIDERS.items():\n        if provider.is_running():\n            return key\n\n    errors: list[tuple[GuiFrontend, BaseException]] = []\n    for key, provider in GUI_PROVIDERS.items():\n        try:\n            provider.create_app()\n            return key\n        except Exception as e:\n            errors.append((key, e))\n\n    raise RuntimeError(  # pragma: no cover\n        f\"Could not find an appropriate GUI frontend: {valid!r}. Tried:\\n\\n\"\n        + \"\\n\".join(f\"- {key.value}: {err}\" for key, err in errors)\n    )\n</code></pre>"},{"location":"reference/ndv/views/#ndv.views.run_app","title":"run_app","text":"<pre><code>run_app() -&gt; None\n</code></pre> <p>Start the GUI application event loop.</p> Source code in <code>ndv/views/_app.py</code> <pre><code>def run_app() -&gt; None:\n    \"\"\"Start the GUI application event loop.\"\"\"\n    GUI_PROVIDERS[gui_frontend()].exec()\n</code></pre>"},{"location":"reference/ndv/views/bases/","title":"ndv.views.bases","text":""},{"location":"reference/ndv/views/bases/#ndv.views.bases","title":"ndv.views.bases","text":"<p>Abstract base classes for views and viewable objects.</p> <p>Classes:</p> <ul> <li> <code>ArrayCanvas</code>           \u2013            <p>ABC for canvases that show array data.</p> </li> <li> <code>ArrayView</code>           \u2013            <p>ABC for ND Array viewers widget.</p> </li> <li> <code>CanvasElement</code>           \u2013            <p>Protocol defining an interactive element on the Canvas.</p> </li> <li> <code>HistogramCanvas</code>           \u2013            <p>A histogram-based view for LookUp Table (LUT) adjustment.</p> </li> <li> <code>LutView</code>           \u2013            <p>Manages LUT properties (contrast, colormap, etc...) in a view object.</p> </li> <li> <code>Mouseable</code>           \u2013            <p>Mixin class for objects that can be interacted with using the mouse.</p> </li> <li> <code>Viewable</code>           \u2013            <p>ABC representing anything that can be viewed on screen.</p> </li> </ul>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.ArrayCanvas","title":"ArrayCanvas","text":"<p>               Bases: <code>GraphicsCanvas</code></p> <p>ABC for canvases that show array data.</p> <p>Methods:</p> <ul> <li> <code>canvas_to_world</code>             \u2013              <p>Map XY canvas position (pixels) to XYZ coordinate in world space.</p> </li> <li> <code>close</code>             \u2013              <p>Close the view/widget.</p> </li> <li> <code>frontend_widget</code>             \u2013              <p>Return the native object backing the viewable objects.</p> </li> <li> <code>set_visible</code>             \u2013              <p>Sets the visibility of the view/widget itself.</p> </li> </ul>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.ArrayCanvas.canvas_to_world","title":"canvas_to_world  <code>abstractmethod</code>","text":"<pre><code>canvas_to_world(pos_xy: tuple[float, float]) -&gt; tuple[float, float, float]\n</code></pre> <p>Map XY canvas position (pixels) to XYZ coordinate in world space.</p> Source code in <code>ndv/views/bases/_graphics/_canvas.py</code> <pre><code>@abstractmethod\ndef canvas_to_world(\n    self, pos_xy: tuple[float, float]\n) -&gt; tuple[float, float, float]:\n    \"\"\"Map XY canvas position (pixels) to XYZ coordinate in world space.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.ArrayCanvas.close","title":"close  <code>abstractmethod</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the view/widget.</p> Source code in <code>ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef close(self) -&gt; None:\n    \"\"\"Close the view/widget.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.ArrayCanvas.frontend_widget","title":"frontend_widget  <code>abstractmethod</code>","text":"<pre><code>frontend_widget() -&gt; Any\n</code></pre> <p>Return the native object backing the viewable objects.</p> Source code in <code>ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef frontend_widget(self) -&gt; Any:\n    \"\"\"Return the native object backing the viewable objects.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.ArrayCanvas.set_visible","title":"set_visible  <code>abstractmethod</code>","text":"<pre><code>set_visible(visible: bool) -&gt; None\n</code></pre> <p>Sets the visibility of the view/widget itself.</p> Source code in <code>ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef set_visible(self, visible: bool) -&gt; None:\n    \"\"\"Sets the visibility of the view/widget itself.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.ArrayView","title":"ArrayView","text":"<pre><code>ArrayView(canvas_widget: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>Viewable</code></p> <p>ABC for ND Array viewers widget.</p> <p>Currently, this is the \"main\" widget that contains the array display and all the controls for interacting with the array, includings sliders, LUTs, and histograms.</p> <p>Methods:</p> <ul> <li> <code>close</code>             \u2013              <p>Close the view/widget.</p> </li> <li> <code>frontend_widget</code>             \u2013              <p>Return the native object backing the viewable objects.</p> </li> <li> <code>set_visible</code>             \u2013              <p>Sets the visibility of the view/widget itself.</p> </li> </ul> Source code in <code>ndv/views/bases/_array_view.py</code> <pre><code>@abstractmethod\ndef __init__(self, canvas_widget: Any, **kwargs: Any) -&gt; None: ...\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.ArrayView.close","title":"close  <code>abstractmethod</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the view/widget.</p> Source code in <code>ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef close(self) -&gt; None:\n    \"\"\"Close the view/widget.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.ArrayView.frontend_widget","title":"frontend_widget  <code>abstractmethod</code>","text":"<pre><code>frontend_widget() -&gt; Any\n</code></pre> <p>Return the native object backing the viewable objects.</p> Source code in <code>ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef frontend_widget(self) -&gt; Any:\n    \"\"\"Return the native object backing the viewable objects.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.ArrayView.set_visible","title":"set_visible  <code>abstractmethod</code>","text":"<pre><code>set_visible(visible: bool) -&gt; None\n</code></pre> <p>Sets the visibility of the view/widget itself.</p> Source code in <code>ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef set_visible(self, visible: bool) -&gt; None:\n    \"\"\"Sets the visibility of the view/widget itself.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.CanvasElement","title":"CanvasElement","text":"<p>               Bases: <code>Mouseable</code></p> <p>Protocol defining an interactive element on the Canvas.</p> <p>Methods:</p> <ul> <li> <code>can_select</code>             \u2013              <p>Defines whether the element can be selected.</p> </li> <li> <code>cursor_at</code>             \u2013              <p>Returns the element's cursor preference at the provided position.</p> </li> <li> <code>move</code>             \u2013              <p>Behavior executed throughout a \"move\" operation.</p> </li> <li> <code>remove</code>             \u2013              <p>Removes the element from the canvas.</p> </li> <li> <code>selected</code>             \u2013              <p>Returns element selection status.</p> </li> <li> <code>set_selected</code>             \u2013              <p>Sets element selection status.</p> </li> <li> <code>set_visible</code>             \u2013              <p>Sets element visibility.</p> </li> <li> <code>start_move</code>             \u2013              <p>Behavior executed at the beginning of a \"move\" operation.</p> </li> <li> <code>visible</code>             \u2013              <p>Defines whether the element is visible on the canvas.</p> </li> </ul>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.CanvasElement.can_select","title":"can_select  <code>abstractmethod</code>","text":"<pre><code>can_select() -&gt; bool\n</code></pre> <p>Defines whether the element can be selected.</p> Source code in <code>ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>@abstractmethod\ndef can_select(self) -&gt; bool:\n    \"\"\"Defines whether the element can be selected.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.CanvasElement.cursor_at","title":"cursor_at","text":"<pre><code>cursor_at(pos: Sequence[float]) -&gt; CursorType | None\n</code></pre> <p>Returns the element's cursor preference at the provided position.</p> Source code in <code>ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>def cursor_at(self, pos: Sequence[float]) -&gt; CursorType | None:\n    \"\"\"Returns the element's cursor preference at the provided position.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.CanvasElement.move","title":"move","text":"<pre><code>move(pos: Sequence[float]) -&gt; None\n</code></pre> <p>Behavior executed throughout a \"move\" operation.</p> <p>In layman's terms, this is the behavior executed during the \"drag\" of a \"click-and-drag\".</p> Source code in <code>ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>def move(self, pos: Sequence[float]) -&gt; None:\n    \"\"\"\n    Behavior executed throughout a \"move\" operation.\n\n    In layman's terms, this is the behavior executed during the \"drag\"\n    of a \"click-and-drag\".\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.CanvasElement.remove","title":"remove","text":"<pre><code>remove() -&gt; None\n</code></pre> <p>Removes the element from the canvas.</p> Source code in <code>ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>def remove(self) -&gt; None:\n    \"\"\"Removes the element from the canvas.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.CanvasElement.selected","title":"selected  <code>abstractmethod</code>","text":"<pre><code>selected() -&gt; bool\n</code></pre> <p>Returns element selection status.</p> Source code in <code>ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>@abstractmethod\ndef selected(self) -&gt; bool:\n    \"\"\"Returns element selection status.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.CanvasElement.set_selected","title":"set_selected  <code>abstractmethod</code>","text":"<pre><code>set_selected(selected: bool) -&gt; None\n</code></pre> <p>Sets element selection status.</p> Source code in <code>ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>@abstractmethod\ndef set_selected(self, selected: bool) -&gt; None:\n    \"\"\"Sets element selection status.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.CanvasElement.set_visible","title":"set_visible  <code>abstractmethod</code>","text":"<pre><code>set_visible(visible: bool) -&gt; None\n</code></pre> <p>Sets element visibility.</p> Source code in <code>ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>@abstractmethod\ndef set_visible(self, visible: bool) -&gt; None:\n    \"\"\"Sets element visibility.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.CanvasElement.start_move","title":"start_move","text":"<pre><code>start_move(pos: Sequence[float]) -&gt; None\n</code></pre> <p>Behavior executed at the beginning of a \"move\" operation.</p> <p>In layman's terms, this is the behavior executed during the the \"click\" of a \"click-and-drag\".</p> Source code in <code>ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>def start_move(self, pos: Sequence[float]) -&gt; None:\n    \"\"\"\n    Behavior executed at the beginning of a \"move\" operation.\n\n    In layman's terms, this is the behavior executed during the the \"click\"\n    of a \"click-and-drag\".\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.CanvasElement.visible","title":"visible  <code>abstractmethod</code>","text":"<pre><code>visible() -&gt; bool\n</code></pre> <p>Defines whether the element is visible on the canvas.</p> Source code in <code>ndv/views/bases/_graphics/_canvas_elements.py</code> <pre><code>@abstractmethod\ndef visible(self) -&gt; bool:\n    \"\"\"Defines whether the element is visible on the canvas.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas","title":"HistogramCanvas","text":"<p>               Bases: <code>GraphicsCanvas</code>, <code>LutView</code></p> <p>A histogram-based view for LookUp Table (LUT) adjustment.</p> <p>Methods:</p> <ul> <li> <code>canvas_to_world</code>             \u2013              <p>Map XY canvas position (pixels) to XYZ coordinate in world space.</p> </li> <li> <code>close</code>             \u2013              <p>Close the view/widget.</p> </li> <li> <code>frontend_widget</code>             \u2013              <p>Return the native object backing the viewable objects.</p> </li> <li> <code>set_auto_scale</code>             \u2013              <p>Set the autoscale button to checked if <code>checked</code> is True.</p> </li> <li> <code>set_channel_name</code>             \u2013              <p>Set the name of the channel to <code>name</code>.</p> </li> <li> <code>set_channel_visible</code>             \u2013              <p>Check or uncheck the visibility indicator of the LUT.</p> </li> <li> <code>set_clims</code>             \u2013              <p>Set the (low, high) contrast limits to <code>clims</code>.</p> </li> <li> <code>set_colormap</code>             \u2013              <p>Set the colormap to <code>cmap</code>.</p> </li> <li> <code>set_data</code>             \u2013              <p>Sets the histogram data.</p> </li> <li> <code>set_gamma</code>             \u2013              <p>Set the gamma value of the LUT.</p> </li> <li> <code>set_log_base</code>             \u2013              <p>Sets the axis scale of the range.</p> </li> <li> <code>set_vertical</code>             \u2013              <p>If True, orient axes vertically (x-axis on left).</p> </li> <li> <code>set_visible</code>             \u2013              <p>Sets the visibility of the view/widget itself.</p> </li> </ul>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.canvas_to_world","title":"canvas_to_world  <code>abstractmethod</code>","text":"<pre><code>canvas_to_world(pos_xy: tuple[float, float]) -&gt; tuple[float, float, float]\n</code></pre> <p>Map XY canvas position (pixels) to XYZ coordinate in world space.</p> Source code in <code>ndv/views/bases/_graphics/_canvas.py</code> <pre><code>@abstractmethod\ndef canvas_to_world(\n    self, pos_xy: tuple[float, float]\n) -&gt; tuple[float, float, float]:\n    \"\"\"Map XY canvas position (pixels) to XYZ coordinate in world space.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.close","title":"close  <code>abstractmethod</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the view/widget.</p> Source code in <code>ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef close(self) -&gt; None:\n    \"\"\"Close the view/widget.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.frontend_widget","title":"frontend_widget  <code>abstractmethod</code>","text":"<pre><code>frontend_widget() -&gt; Any\n</code></pre> <p>Return the native object backing the viewable objects.</p> Source code in <code>ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef frontend_widget(self) -&gt; Any:\n    \"\"\"Return the native object backing the viewable objects.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.set_auto_scale","title":"set_auto_scale  <code>abstractmethod</code>","text":"<pre><code>set_auto_scale(checked: bool) -&gt; None\n</code></pre> <p>Set the autoscale button to checked if <code>checked</code> is True.</p> Source code in <code>ndv/views/bases/_lut_view.py</code> <pre><code>@abstractmethod\ndef set_auto_scale(self, checked: bool) -&gt; None:\n    \"\"\"Set the autoscale button to checked if `checked` is True.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.set_channel_name","title":"set_channel_name  <code>abstractmethod</code>","text":"<pre><code>set_channel_name(name: str) -&gt; None\n</code></pre> <p>Set the name of the channel to <code>name</code>.</p> Source code in <code>ndv/views/bases/_lut_view.py</code> <pre><code>@abstractmethod\ndef set_channel_name(self, name: str) -&gt; None:\n    \"\"\"Set the name of the channel to `name`.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.set_channel_visible","title":"set_channel_visible  <code>abstractmethod</code>","text":"<pre><code>set_channel_visible(visible: bool) -&gt; None\n</code></pre> <p>Check or uncheck the visibility indicator of the LUT.</p> <p>Usually corresponds to a checkbox.</p> Source code in <code>ndv/views/bases/_lut_view.py</code> <pre><code>@abstractmethod\ndef set_channel_visible(self, visible: bool) -&gt; None:\n    \"\"\"Check or uncheck the visibility indicator of the LUT.\n\n    Usually corresponds to a checkbox.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.set_clims","title":"set_clims  <code>abstractmethod</code>","text":"<pre><code>set_clims(clims: tuple[float, float]) -&gt; None\n</code></pre> <p>Set the (low, high) contrast limits to <code>clims</code>.</p> <p>Usually this will be a range slider or two text boxes.</p> Source code in <code>ndv/views/bases/_lut_view.py</code> <pre><code>@abstractmethod\ndef set_clims(self, clims: tuple[float, float]) -&gt; None:\n    \"\"\"Set the (low, high) contrast limits to `clims`.\n\n    Usually this will be a range slider or two text boxes.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.set_colormap","title":"set_colormap  <code>abstractmethod</code>","text":"<pre><code>set_colormap(cmap: Colormap) -&gt; None\n</code></pre> <p>Set the colormap to <code>cmap</code>.</p> <p>Usually corresponds to a dropdown menu.</p> Source code in <code>ndv/views/bases/_lut_view.py</code> <pre><code>@abstractmethod\ndef set_colormap(self, cmap: cmap.Colormap) -&gt; None:\n    \"\"\"Set the colormap to `cmap`.\n\n    Usually corresponds to a dropdown menu.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.set_data","title":"set_data","text":"<pre><code>set_data(values: ndarray, bin_edges: ndarray) -&gt; None\n</code></pre> <p>Sets the histogram data.</p> Properties <p>values : np.ndarray     The histogram values. bin_edges : np.ndarray     The bin edges of the histogram.</p> Source code in <code>ndv/views/bases/_graphics/_canvas.py</code> <pre><code>def set_data(self, values: np.ndarray, bin_edges: np.ndarray) -&gt; None:\n    \"\"\"Sets the histogram data.\n\n    Properties\n    ----------\n    values : np.ndarray\n        The histogram values.\n    bin_edges : np.ndarray\n        The bin edges of the histogram.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.set_gamma","title":"set_gamma","text":"<pre><code>set_gamma(gamma: float) -&gt; None\n</code></pre> <p>Set the gamma value of the LUT.</p> Source code in <code>ndv/views/bases/_lut_view.py</code> <pre><code>def set_gamma(self, gamma: float) -&gt; None:\n    \"\"\"Set the gamma value of the LUT.\"\"\"\n    return None\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.set_log_base","title":"set_log_base","text":"<pre><code>set_log_base(base: float | None) -&gt; None\n</code></pre> <p>Sets the axis scale of the range.</p> Properties <p>enabled : bool     If true, the range will be displayed with a logarithmic (base 10)     scale. If false, the range will be displayed with a linear scale.</p> Source code in <code>ndv/views/bases/_graphics/_canvas.py</code> <pre><code>def set_log_base(self, base: float | None) -&gt; None:\n    \"\"\"Sets the axis scale of the range.\n\n    Properties\n    ----------\n    enabled : bool\n        If true, the range will be displayed with a logarithmic (base 10)\n        scale. If false, the range will be displayed with a linear scale.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.set_vertical","title":"set_vertical","text":"<pre><code>set_vertical(vertical: bool) -&gt; None\n</code></pre> <p>If True, orient axes vertically (x-axis on left).</p> Source code in <code>ndv/views/bases/_graphics/_canvas.py</code> <pre><code>def set_vertical(self, vertical: bool) -&gt; None:\n    \"\"\"If True, orient axes vertically (x-axis on left).\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.HistogramCanvas.set_visible","title":"set_visible  <code>abstractmethod</code>","text":"<pre><code>set_visible(visible: bool) -&gt; None\n</code></pre> <p>Sets the visibility of the view/widget itself.</p> Source code in <code>ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef set_visible(self, visible: bool) -&gt; None:\n    \"\"\"Sets the visibility of the view/widget itself.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView","title":"LutView","text":"<p>               Bases: <code>Viewable</code></p> <p>Manages LUT properties (contrast, colormap, etc...) in a view object.</p> <p>Methods:</p> <ul> <li> <code>close</code>             \u2013              <p>Close the view/widget.</p> </li> <li> <code>frontend_widget</code>             \u2013              <p>Return the native object backing the viewable objects.</p> </li> <li> <code>set_auto_scale</code>             \u2013              <p>Set the autoscale button to checked if <code>checked</code> is True.</p> </li> <li> <code>set_channel_name</code>             \u2013              <p>Set the name of the channel to <code>name</code>.</p> </li> <li> <code>set_channel_visible</code>             \u2013              <p>Check or uncheck the visibility indicator of the LUT.</p> </li> <li> <code>set_clims</code>             \u2013              <p>Set the (low, high) contrast limits to <code>clims</code>.</p> </li> <li> <code>set_colormap</code>             \u2013              <p>Set the colormap to <code>cmap</code>.</p> </li> <li> <code>set_gamma</code>             \u2013              <p>Set the gamma value of the LUT.</p> </li> <li> <code>set_visible</code>             \u2013              <p>Sets the visibility of the view/widget itself.</p> </li> </ul>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView.close","title":"close  <code>abstractmethod</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the view/widget.</p> Source code in <code>ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef close(self) -&gt; None:\n    \"\"\"Close the view/widget.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView.frontend_widget","title":"frontend_widget  <code>abstractmethod</code>","text":"<pre><code>frontend_widget() -&gt; Any\n</code></pre> <p>Return the native object backing the viewable objects.</p> Source code in <code>ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef frontend_widget(self) -&gt; Any:\n    \"\"\"Return the native object backing the viewable objects.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView.set_auto_scale","title":"set_auto_scale  <code>abstractmethod</code>","text":"<pre><code>set_auto_scale(checked: bool) -&gt; None\n</code></pre> <p>Set the autoscale button to checked if <code>checked</code> is True.</p> Source code in <code>ndv/views/bases/_lut_view.py</code> <pre><code>@abstractmethod\ndef set_auto_scale(self, checked: bool) -&gt; None:\n    \"\"\"Set the autoscale button to checked if `checked` is True.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView.set_channel_name","title":"set_channel_name  <code>abstractmethod</code>","text":"<pre><code>set_channel_name(name: str) -&gt; None\n</code></pre> <p>Set the name of the channel to <code>name</code>.</p> Source code in <code>ndv/views/bases/_lut_view.py</code> <pre><code>@abstractmethod\ndef set_channel_name(self, name: str) -&gt; None:\n    \"\"\"Set the name of the channel to `name`.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView.set_channel_visible","title":"set_channel_visible  <code>abstractmethod</code>","text":"<pre><code>set_channel_visible(visible: bool) -&gt; None\n</code></pre> <p>Check or uncheck the visibility indicator of the LUT.</p> <p>Usually corresponds to a checkbox.</p> Source code in <code>ndv/views/bases/_lut_view.py</code> <pre><code>@abstractmethod\ndef set_channel_visible(self, visible: bool) -&gt; None:\n    \"\"\"Check or uncheck the visibility indicator of the LUT.\n\n    Usually corresponds to a checkbox.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView.set_clims","title":"set_clims  <code>abstractmethod</code>","text":"<pre><code>set_clims(clims: tuple[float, float]) -&gt; None\n</code></pre> <p>Set the (low, high) contrast limits to <code>clims</code>.</p> <p>Usually this will be a range slider or two text boxes.</p> Source code in <code>ndv/views/bases/_lut_view.py</code> <pre><code>@abstractmethod\ndef set_clims(self, clims: tuple[float, float]) -&gt; None:\n    \"\"\"Set the (low, high) contrast limits to `clims`.\n\n    Usually this will be a range slider or two text boxes.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView.set_colormap","title":"set_colormap  <code>abstractmethod</code>","text":"<pre><code>set_colormap(cmap: Colormap) -&gt; None\n</code></pre> <p>Set the colormap to <code>cmap</code>.</p> <p>Usually corresponds to a dropdown menu.</p> Source code in <code>ndv/views/bases/_lut_view.py</code> <pre><code>@abstractmethod\ndef set_colormap(self, cmap: cmap.Colormap) -&gt; None:\n    \"\"\"Set the colormap to `cmap`.\n\n    Usually corresponds to a dropdown menu.\n    \"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView.set_gamma","title":"set_gamma","text":"<pre><code>set_gamma(gamma: float) -&gt; None\n</code></pre> <p>Set the gamma value of the LUT.</p> Source code in <code>ndv/views/bases/_lut_view.py</code> <pre><code>def set_gamma(self, gamma: float) -&gt; None:\n    \"\"\"Set the gamma value of the LUT.\"\"\"\n    return None\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.LutView.set_visible","title":"set_visible  <code>abstractmethod</code>","text":"<pre><code>set_visible(visible: bool) -&gt; None\n</code></pre> <p>Sets the visibility of the view/widget itself.</p> Source code in <code>ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef set_visible(self, visible: bool) -&gt; None:\n    \"\"\"Sets the visibility of the view/widget itself.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.Mouseable","title":"Mouseable","text":"<p>Mixin class for objects that can be interacted with using the mouse.</p> <p>The signals here are to be emitted by the view object that inherits this class; usually by intercepting native mouse events with <code>filter_mouse_events</code>.</p> <p>The methods allow the object to handle its own mouse events before emitting the signals. If the method returns <code>True</code>, the event is considered handled and should not be passed to the next receiver in the chain.</p>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.Viewable","title":"Viewable","text":"<p>               Bases: <code>ABC</code></p> <p>ABC representing anything that can be viewed on screen.</p> <p>For example, a widget, a window, a frame, canvas, etc.</p> <p>Methods:</p> <ul> <li> <code>close</code>             \u2013              <p>Close the view/widget.</p> </li> <li> <code>frontend_widget</code>             \u2013              <p>Return the native object backing the viewable objects.</p> </li> <li> <code>set_visible</code>             \u2013              <p>Sets the visibility of the view/widget itself.</p> </li> </ul>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.Viewable.close","title":"close  <code>abstractmethod</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the view/widget.</p> Source code in <code>ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef close(self) -&gt; None:\n    \"\"\"Close the view/widget.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.Viewable.frontend_widget","title":"frontend_widget  <code>abstractmethod</code>","text":"<pre><code>frontend_widget() -&gt; Any\n</code></pre> <p>Return the native object backing the viewable objects.</p> Source code in <code>ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef frontend_widget(self) -&gt; Any:\n    \"\"\"Return the native object backing the viewable objects.\"\"\"\n</code></pre>"},{"location":"reference/ndv/views/bases/#ndv.views.bases.Viewable.set_visible","title":"set_visible  <code>abstractmethod</code>","text":"<pre><code>set_visible(visible: bool) -&gt; None\n</code></pre> <p>Sets the visibility of the view/widget itself.</p> Source code in <code>ndv/views/bases/_view_base.py</code> <pre><code>@abstractmethod\ndef set_visible(self, visible: bool) -&gt; None:\n    \"\"\"Sets the visibility of the view/widget itself.\"\"\"\n</code></pre>"}]}